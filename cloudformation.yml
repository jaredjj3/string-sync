AWSTemplateFormatVersion: 2010-09-09
Description: A stack for deploying StringSync in AWS

Parameters:
  BranchName:
    Description: CodeCommit repository branch name
    Type: String
    Default: master

  DbName:
    Description: The database name
    Type: String
    MinLength: '1'
    MaxLength: '64'
    AllowedPattern: '[a-zA-Z][a-zA-Z0-9]*'
    ConstraintDescription: must begin with a letter and contain only alphanumeric
      characters.

  DbUsername:
    NoEcho: true
    Description: The database admin account username
    Type: String
    MinLength: '1'
    MaxLength: '16'
    AllowedPattern: '[a-zA-Z][a-zA-Z0-9]*'
    ConstraintDescription: must begin with a letter and contain only alphanumeric
      characters.

  DbPassword:
    NoEcho: true
    Description: The database admin account password
    Type: String
    MinLength: '1'
    MaxLength: '41'
    AllowedPattern: '[a-zA-Z0-9]+'
    ConstraintDescription: must contain only alphanumeric characters.

  DbAllocatedStorage:
    Default: '20'
    Description: The size of the database (Gb)
    Type: Number
    MinValue: '20'
    MaxValue: '1024'
    ConstraintDescription: must be between 5 and 1024Gb.

  DbInstanceClass:
    Description: The database instance type
    Type: String
    Default: db.t3.micro
    AllowedValues:
      - db.t3.micro
      - db.t3.small
      - db.t3.medium
      - db.t3.large
    ConstraintDescription: must select a valid database instance type.

  ApiCpu:
    Type: Number
    Default: '256'
    Description: How much CPU to give the container. 1024 is 1 CPU.x

  ApiMemory:
    Type: Number
    Default: '512'
    Description: How much memory in megabytes to give the container.

  ApiPort:
    Type: Number
    Default: '3000'
    Description: What port number the application inside the docker container is binding to.

  ApiSessionSecret:
    NoEcho: true
    Type: String
    Description: The secret to encrypt session data for the API.

  WorkerCpu:
    Type: Number
    Default: '256'
    Description: How much CPU to give the container. 1024 is 1 CPU.

  WorkerMemory:
    Type: Number
    Default: '512'
    Description: How much memory in megabytes to give the container.

  WorkerPort:
    Type: Number
    Default: '3000'
    Description: What port number the application inside the docker container is binding to.

  VideoProcessingStack:
    Type: String
    Default: ''
    Description: The name of the video processing stack.

Mappings:
  # Hard values for the subnet masks. These masks define
  # the range of internal IP addresses that can be assigned.
  # The VPC can have all IP's from 10.0.0.0 to 10.0.255.255
  # There are two subnets which cover the ranges:
  #
  # 10.0.0.0 - 10.0.0.255
  # 10.0.1.0 - 10.0.1.255
  #
  # If you need more IP addresses (perhaps you have so many
  # instances that you run out) then you can customize these
  # ranges to add more
  SubnetConfig:
    VPC:
      CIDR: '10.0.0.0/16'
    Public1:
      CIDR: '10.0.0.0/24'
    Public2:
      CIDR: '10.0.1.0/24'
    Private1:
      CIDR: '10.0.2.0/24'
    Private2:
      CIDR: '10.0.3.0/24'

Resources:
  CodePipelineArtifactStore:
    DeletionPolicy: Delete
    Type: AWS::S3::Bucket

  FrontendBucketPolicy:
    Type: AWS::S3::BucketPolicy
    Properties:
      Bucket: !Ref FrontendBucket
      PolicyDocument:
        Version: '2012-10-17'
        Statement:
          Sid: PublicReadForGetBucketObjects
          Effect: Allow
          Principal: '*'
          Action: 's3:GetObject'
          Resource: !Join ['', ['arn:aws:s3:::', !Ref FrontendBucket, '/*']]

  FrontendBucket:
    DeletionPolicy: Delete
    Type: AWS::S3::Bucket
    Properties:
      AccessControl: PublicRead
      MetricsConfigurations:
        - Id: EntireBucket
      WebsiteConfiguration:
        IndexDocument: index.html

  CodeCommitRepository:
    Type: AWS::CodeCommit::Repository
    Properties:
      RepositoryName: !Ref AWS::StackName

  ApiImageRepository:
    Type: AWS::ECR::Repository
    DeletionPolicy: Delete
    Properties:
      LifecyclePolicy:
        LifecyclePolicyText: |
          {
            "rules": [
              {
                "rulePriority": 1,
                "description": "Keep only one untagged image, expire all others",
                "selection": {
                  "tagStatus": "untagged",
                  "countType": "imageCountMoreThan",
                  "countNumber": 1
                },
                "action": {
                  "type": "expire"
                }
              }
            ]
          }

  CodeBuildServiceRole:
    Type: AWS::IAM::Role
    Properties:
      Path: /
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - codebuild.amazonaws.com
            Action: sts:AssumeRole
      Policies:
        - PolicyName: AWS-CodeBuild-Service-3
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - 'logs:*'
                  - 'ec2:*'
                  - 's3:*'
                  - 'ecr:*'
                  - 'cloudwatch:*'
                Resource: '*'

  CodeBuildSecretsBucket:
    Type: AWS::S3::Bucket
    DeletionPolicy: Delete

  CloudWatchEventRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - events.amazonaws.com
            Action: sts:AssumeRole
      Path: /
      Policies:
        - PolicyName: cwe-pipeline-execution
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action: codepipeline:StartPipelineExecution
                Resource: '*'

  CloudWatchEventRule:
    Type: AWS::Events::Rule
    Properties:
      EventPattern:
        source:
          - aws.codecommit
        detail-type:
          - 'CodeCommit Repository State Change'
        resources:
          - !GetAtt CodeCommitRepository.Arn
        detail:
          event:
            - referenceCreated
            - referenceUpdated
          referenceType:
            - branch
          referenceName:
            - !Ref BranchName
      Targets:
        - Arn:
            !Join [
              '',
              ['arn:aws:codepipeline:', !Ref 'AWS::Region', ':', !Ref 'AWS::AccountId', ':', !Ref CodePipeline],
            ]
          RoleArn: !GetAtt CloudWatchEventRole.Arn
          Id: !Ref AWS::StackName

  CodePipelineServiceRole:
    Type: AWS::IAM::Role
    Properties:
      Path: /
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - codepipeline.amazonaws.com
            Action: sts:AssumeRole
      Policies:
        - PolicyName: AWS-CodePipeline-Service-3
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - 'codecommit:CancelUploadArchive'
                  - 'codecommit:GetBranch'
                  - 'codecommit:GetCommit'
                  - 'codecommit:GetUploadArchiveStatus'
                  - 'codecommit:UploadArchive'
                Resource: '*'
              - Effect: Allow
                Action:
                  - 'codedeploy:CreateDeployment'
                  - 'codedeploy:GetApplicationRevision'
                  - 'codedeploy:GetDeployment'
                  - 'codedeploy:GetDeploymentConfig'
                  - 'codedeploy:RegisterApplicationRevision'
                Resource: '*'
              - Effect: Allow
                Action:
                  - 'codebuild:BatchGetBuilds'
                  - 'codebuild:StartBuild'
                Resource: '*'
              - Effect: Allow
                Action:
                  - 'devicefarm:ListProjects'
                  - 'devicefarm:ListDevicePools'
                  - 'devicefarm:GetRun'
                  - 'devicefarm:GetUpload'
                  - 'devicefarm:CreateUpload'
                  - 'devicefarm:ScheduleRun'
                Resource: '*'
              - Effect: Allow
                Action:
                  - 'lambda:InvokeFunction'
                  - 'lambda:ListFunctions'
                Resource: '*'
              - Effect: Allow
                Action:
                  - 'iam:PassRole'
                Resource: '*'
              - Effect: Allow
                Action:
                  - 'elasticbeanstalk:*'
                  - 'ec2:*'
                  - 'elasticloadbalancing:*'
                  - 'autoscaling:*'
                  - 'cloudwatch:*'
                  - 's3:*'
                  - 'sns:*'
                  - 'cloudformation:*'
                  - 'rds:*'
                  - 'sqs:*'
                  - 'ecs:*'
                Resource: '*'

  CodeBuildCacheBucket:
    Type: AWS::S3::Bucket

  CodeBuildProject:
    Type: AWS::CodeBuild::Project
    Properties:
      Name: !Ref AWS::StackName
      ServiceRole: !GetAtt CodeBuildServiceRole.Arn
      TimeoutInMinutes: 15
      Cache:
        Type: S3
        Location: !Ref CodeBuildCacheBucket
        Modes:
          - LOCAL_DOCKER_LAYER_CACHE
          - LOCAL_CUSTOM_CACHE
      Artifacts:
        Type: CODEPIPELINE
      Environment:
        Type: LINUX_CONTAINER
        ComputeType: BUILD_GENERAL1_MEDIUM
        Image: aws/codebuild/standard:4.0
        PrivilegedMode: true
        EnvironmentVariables:
          - Name: AWS_ACCOUNT_ID
            Type: PLAINTEXT
            Value: !Ref AWS::AccountId
          - Name: IMAGE_REPO_NAME
            Type: PLAINTEXT
            Value: !Ref ApiImageRepository
          - Name: REACT_APP_SERVER_URI
            Type: PLAINTEXT
            Value: !GetAtt PublicLoadBalancer.DNSName
          - Name: S3_SECRETS_BUCKET
            Type: PLAINTEXT
            Value: !Ref CodeBuildSecretsBucket
      Source:
        Type: CODEPIPELINE

  CodePipeline:
    Type: AWS::CodePipeline::Pipeline
    Properties:
      RoleArn: !GetAtt CodePipelineServiceRole.Arn
      RestartExecutionOnUpdate: false
      ArtifactStore:
        Type: S3
        Location: !Ref CodePipelineArtifactStore
      Stages:
        - Name: Source
          Actions:
            - Name: SourceAction
              RunOrder: 1
              ActionTypeId:
                Category: Source
                Owner: AWS
                Provider: CodeCommit
                Version: '1'
              OutputArtifacts:
                - Name: SourceOutput
              Configuration:
                RepositoryName: !Ref AWS::StackName
                BranchName: !Ref BranchName
                PollForSourceChanges: false
        - Name: Build
          Actions:
            - Name: BuildAction
              RunOrder: 2
              ActionTypeId:
                Category: Build
                Owner: AWS
                Provider: CodeBuild
                Version: '1'
              InputArtifacts:
                - Name: SourceOutput
              OutputArtifacts:
                - Name: BuildOutput
              Configuration:
                ProjectName: !Ref CodeBuildProject
                PrimarySource: SourceOutput
        - Name: Deploy
          Actions:
            - Name: DeployApi
              RunOrder: 3
              ActionTypeId:
                Category: Deploy
                Owner: AWS
                Provider: ECS
                Version: '1'
              InputArtifacts:
                - Name: BuildOutput
              Configuration:
                ClusterName: !Ref Cluster
                ServiceName: !Ref ApiService
                FileName: imagedefinitions.api.json
            - Name: DeployWorker
              RunOrder: 3
              ActionTypeId:
                Category: Deploy
                Owner: AWS
                Provider: ECS
                Version: '1'
              InputArtifacts:
                - Name: BuildOutput
              Configuration:
                ClusterName: !Ref Cluster
                ServiceName: !Ref WorkerService
                FileName: imagedefinitions.worker.json
            - Name: DeployFrontend
              RunOrder: 3
              ActionTypeId:
                Category: Deploy
                Owner: AWS
                Provider: S3
                Version: '1'
              InputArtifacts:
                - Name: BuildOutput
              Configuration:
                BucketName: !Ref FrontendBucket
                Extract: true

  # VPC in which containers will be networked.
  # It has two public subnets
  # We distribute the subnets across the first two available subnets
  # for the region, for high availability.
  VPC:
    Type: AWS::EC2::VPC
    Properties:
      EnableDnsSupport: true
      EnableDnsHostnames: true

      CidrBlock: !FindInMap ['SubnetConfig', 'VPC', 'CIDR']

  # Two public subnets, where containers can have public IP addresses
  PublicSubnet1:
    Type: AWS::EC2::Subnet
    Properties:
      AvailabilityZone: !Select [0, Fn::GetAZs: { Ref: 'AWS::Region' }]
      VpcId: !Ref 'VPC'
      CidrBlock: !FindInMap ['SubnetConfig', 'Public1', 'CIDR']
      MapPublicIpOnLaunch: true

  PublicSubnet2:
    Type: AWS::EC2::Subnet
    Properties:
      AvailabilityZone: !Select [1, Fn::GetAZs: { Ref: 'AWS::Region' }]
      VpcId: !Ref 'VPC'
      CidrBlock: !FindInMap ['SubnetConfig', 'Public2', 'CIDR']
      MapPublicIpOnLaunch: true

  # Two private subnets where containers will only have private
  # IP addresses, and will only be reachable by other members of the
  # VPC
  PrivateSubnet1:
    Type: AWS::EC2::Subnet
    Properties:
      AvailabilityZone: !Select [0, Fn::GetAZs: { Ref: 'AWS::Region' }]
      VpcId: !Ref 'VPC'
      CidrBlock: !FindInMap ['SubnetConfig', 'Private1', 'CIDR']
  PrivateSubnet2:
    Type: AWS::EC2::Subnet
    Properties:
      AvailabilityZone: !Select [1, Fn::GetAZs: { Ref: 'AWS::Region' }]
      VpcId: !Ref 'VPC'
      CidrBlock: !FindInMap ['SubnetConfig', 'Private2', 'CIDR']

  # Setup networking resources for the public subnets. Containers
  # in the public subnets have public IP addresses and the routing table
  # sends network traffic via the internet gateway.
  InternetGateway:
    Type: AWS::EC2::InternetGateway
  GatewayAttachement:
    Type: AWS::EC2::VPCGatewayAttachment
    Properties:
      VpcId: !Ref 'VPC'
      InternetGatewayId: !Ref 'InternetGateway'
  PublicRouteTable:
    Type: AWS::EC2::RouteTable
    Properties:
      VpcId: !Ref 'VPC'
  PublicRoute:
    Type: AWS::EC2::Route
    DependsOn: GatewayAttachement
    Properties:
      RouteTableId: !Ref 'PublicRouteTable'
      DestinationCidrBlock: '0.0.0.0/0'
      GatewayId: !Ref 'InternetGateway'
  PublicSubnet1RouteTableAssociation:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      SubnetId: !Ref PublicSubnet1
      RouteTableId: !Ref PublicRouteTable
  PublicSubnet2RouteTableAssociation:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      SubnetId: !Ref PublicSubnet2
      RouteTableId: !Ref PublicRouteTable

  # Setup networking resources for the private subnets. Containers
  # in these subnets have only private IP addresses, and must use a NAT
  # gateway to talk to the internet. We launch two NAT gateways, one for
  # each private subnet.

  # UNCOMMENT IF ACCESS FROM A PRIVATE SUBNET TO THE INTERNET IS NEEDED

  # NatGateway1Attachment:
  #   Type: AWS::EC2::EIP
  #   DependsOn: GatewayAttachement
  #   Properties:
  #     Domain: vpc

  # NatGateway2Attachment:
  #   Type: AWS::EC2::EIP
  #   DependsOn: GatewayAttachement
  #   Properties:
  #     Domain: vpc

  # NatGateway1:
  #   Type: AWS::EC2::NatGateway
  #   Properties:
  #     AllocationId: !GetAtt NatGateway1Attachment.AllocationId
  #     SubnetId: !Ref PublicSubnet1

  # NatGateway2:
  #   Type: AWS::EC2::NatGateway
  #   Properties:
  #     AllocationId: !GetAtt NatGateway2Attachment.AllocationId
  #     SubnetId: !Ref PublicSubnet2

  PrivateRouteTable1:
    Type: AWS::EC2::RouteTable
    Properties:
      VpcId: !Ref 'VPC'

  # PrivateRoute1:
  #   Type: AWS::EC2::Route
  #   Properties:
  #     RouteTableId: !Ref PrivateRouteTable1
  #     DestinationCidrBlock: 0.0.0.0/0
  #     NatGatewayId: !Ref NatGateway1

  PrivateRouteTable1Association:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      RouteTableId: !Ref PrivateRouteTable1
      SubnetId: !Ref PrivateSubnet1

  PrivateRouteTable2:
    Type: AWS::EC2::RouteTable
    Properties:
      VpcId: !Ref 'VPC'

  # PrivateRoute2:
  #   Type: AWS::EC2::Route
  #   Properties:
  #     RouteTableId: !Ref PrivateRouteTable2
  #     DestinationCidrBlock: 0.0.0.0/0
  #     NatGatewayId: !Ref NatGateway2

  PrivateRouteTable2Association:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      RouteTableId: !Ref PrivateRouteTable2
      SubnetId: !Ref PrivateSubnet2

  # A security group for the containers we will run in Fargate.
  # Three rules, allowing network traffic from a public facing load
  # balancer, a private internal load balancer, and from other members
  # of the security group.
  #
  # Remove any of the following ingress rules that are not needed.
  FargateContainerSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: Access to the Fargate containers
      VpcId: !Ref 'VPC'
  EcsSecurityGroupIngressFromPublicALB:
    Type: AWS::EC2::SecurityGroupIngress
    Properties:
      Description: Ingress from the public ALB
      GroupId: !Ref 'FargateContainerSecurityGroup'
      IpProtocol: '-1'
      SourceSecurityGroupId: !Ref 'PublicLoadBalancerSG'
  EcsSecurityGroupIngressFromPrivateALB:
    Type: AWS::EC2::SecurityGroupIngress
    Properties:
      Description: Ingress from the private ALB
      GroupId: !Ref 'FargateContainerSecurityGroup'
      IpProtocol: '-1'
      SourceSecurityGroupId: !Ref 'PrivateLoadBalancerSG'
  EcsSecurityGroupIngressFromSelf:
    Type: AWS::EC2::SecurityGroupIngress
    Properties:
      Description: Ingress from other containers in the same security group
      GroupId: !Ref 'FargateContainerSecurityGroup'
      IpProtocol: '-1'
      SourceSecurityGroupId: !Ref 'FargateContainerSecurityGroup'

  # A public facing load balancer, this is used for accepting traffic from the public
  # internet and directing it to public facing microservices
  PublicLoadBalancerSG:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: Access to the public facing load balancer
      VpcId: !Ref 'VPC'
      SecurityGroupIngress:
        # Allow access to ALB from anywhere on the internet
        - CidrIp: 0.0.0.0/0
          IpProtocol: '-1'
  PublicLoadBalancer:
    Type: AWS::ElasticLoadBalancingV2::LoadBalancer
    DependsOn: GatewayAttachement
    Properties:
      Scheme: internet-facing
      LoadBalancerAttributes:
        - Key: idle_timeout.timeout_seconds
          Value: '30'
      Subnets:
        # The load balancer is placed into the public subnets, so that traffic
        # from the internet can reach the load balancer directly via the internet gateway
        - !Ref PublicSubnet1
        - !Ref PublicSubnet2
      SecurityGroups: [!Ref PublicLoadBalancerSG]
  # A dummy target group is used to setup the ALB to just drop traffic
  # initially, before any real service target groups have been added.
  DummyTargetGroupPublic:
    Type: AWS::ElasticLoadBalancingV2::TargetGroup
    Properties:
      HealthCheckIntervalSeconds: 6
      HealthCheckPath: /
      HealthCheckProtocol: HTTP
      HealthCheckTimeoutSeconds: 5
      HealthyThresholdCount: 2
      Name: !Join ['-', [!Ref 'AWS::StackName', 'drop-1']]
      Port: 80
      Protocol: HTTP
      UnhealthyThresholdCount: 2
      VpcId: !Ref 'VPC'
  PublicLoadBalancerListener:
    Type: AWS::ElasticLoadBalancingV2::Listener
    DependsOn:
      - PublicLoadBalancer
    Properties:
      DefaultActions:
        - TargetGroupArn: !Ref 'DummyTargetGroupPublic'
          Type: 'forward'
      LoadBalancerArn: !Ref 'PublicLoadBalancer'
      Port: 80
      Protocol: HTTP

  # An internal load balancer, this would be used for a service that is not
  # directly accessible to the public, but instead should only receive traffic
  # from your other services.
  PrivateLoadBalancerSG:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: Access to the internal load balancer
      VpcId: !Ref 'VPC'
  PrivateLoadBalancerIngressFromECS:
    Type: AWS::EC2::SecurityGroupIngress
    Properties:
      Description: Only accept traffic from a container in the fargate container security group
      GroupId: !Ref 'PrivateLoadBalancerSG'
      IpProtocol: -1
      SourceSecurityGroupId: !Ref 'FargateContainerSecurityGroup'
  PrivateLoadBalancer:
    Type: AWS::ElasticLoadBalancingV2::LoadBalancer
    Properties:
      Scheme: internal
      LoadBalancerAttributes:
        - Key: idle_timeout.timeout_seconds
          Value: '30'
      Subnets:
        # This load balancer is put into the private subnet, so that there is no
        # route for the public to even be able to access the private load balancer.
        - !Ref PrivateSubnet1
        - !Ref PrivateSubnet2
      SecurityGroups: [!Ref 'PrivateLoadBalancerSG']
  # This dummy target group is used to setup the ALB to just drop traffic
  # initially, before any real service target groups have been added.
  DummyTargetGroupPrivate:
    Type: AWS::ElasticLoadBalancingV2::TargetGroup
    Properties:
      HealthCheckIntervalSeconds: 6
      HealthCheckPath: /
      HealthCheckProtocol: HTTP
      HealthCheckTimeoutSeconds: 5
      HealthyThresholdCount: 2
      Name: !Join ['-', [!Ref 'AWS::StackName', 'drop-2']]
      Port: 80
      Protocol: HTTP
      UnhealthyThresholdCount: 2
      VpcId: !Ref 'VPC'
  PrivateLoadBalancerListener:
    Type: AWS::ElasticLoadBalancingV2::Listener
    DependsOn:
      - PrivateLoadBalancer
    Properties:
      DefaultActions:
        - TargetGroupArn: !Ref 'DummyTargetGroupPrivate'
          Type: 'forward'
      LoadBalancerArn: !Ref 'PrivateLoadBalancer'
      Port: 80
      Protocol: HTTP

  # This is an IAM role which authorizes ECS to manage resources on your
  # account on your behalf, such as updating your load balancer with the
  # details of where your containers are, so that traffic can reach your
  # containers.
  ECSRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Statement:
          - Effect: Allow
            Principal:
              Service: [ecs.amazonaws.com]
            Action: ['sts:AssumeRole']
      Path: /
      Policies:
        - PolicyName: ecs-service
          PolicyDocument:
            Statement:
              - Effect: Allow
                Action:
                  # Rules which allow ECS to attach network interfaces to instances
                  # on your behalf in order for awsvpc networking mode to work right
                  - 'ec2:AttachNetworkInterface'
                  - 'ec2:CreateNetworkInterface'
                  - 'ec2:CreateNetworkInterfacePermission'
                  - 'ec2:DeleteNetworkInterface'
                  - 'ec2:DeleteNetworkInterfacePermission'
                  - 'ec2:Describe*'
                  - 'ec2:DetachNetworkInterface'

                  # Rules which allow ECS to update load balancers on your behalf
                  # with the information sabout how to send traffic to your containers
                  - 'elasticloadbalancing:DeregisterInstancesFromLoadBalancer'
                  - 'elasticloadbalancing:DeregisterTargets'
                  - 'elasticloadbalancing:Describe*'
                  - 'elasticloadbalancing:RegisterInstancesWithLoadBalancer'
                  - 'elasticloadbalancing:RegisterTargets'
                Resource: '*'

  ElasticacheSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: Access to the Elasticache service.
      VpcId: !Ref 'VPC'
  ElasticacheSecurityGroupIngressFromFargate:
    Type: AWS::EC2::SecurityGroupIngress
    Properties:
      Description: Ingress from Fargate Containers
      GroupId: !Ref 'ElasticacheSecurityGroup'
      IpProtocol: '-1'
      SourceSecurityGroupId: !Ref 'FargateContainerSecurityGroup'
  ElasticacheSubnetGroup:
    Type: 'AWS::ElastiCache::SubnetGroup'
    Properties:
      Description: Cache Subnet Group
      SubnetIds:
        - !Ref PrivateSubnet1
        - !Ref PrivateSubnet2
  ElasticacheCluster:
    Type: AWS::ElastiCache::CacheCluster
    Properties:
      Engine: redis
      EngineVersion: '5.0.0'
      CacheNodeType: cache.t2.micro
      NumCacheNodes: 1
      CacheSubnetGroupName: !Ref ElasticacheSubnetGroup
      VpcSecurityGroupIds:
        - !GetAtt ElasticacheSecurityGroup.GroupId

  DbSubnetGroup:
    Type: AWS::RDS::DBSubnetGroup
    Properties:
      DBSubnetGroupDescription: DB subnet group for the master DB
      SubnetIds:
        - !Ref PrivateSubnet1
        - !Ref PrivateSubnet2

  Db:
    Type: AWS::RDS::DBInstance
    DeletionPolicy: Snapshot
    Properties:
      DBName: !Ref 'DbName'
      AllocatedStorage: !Ref 'DbAllocatedStorage'
      DBInstanceClass: !Ref 'DbInstanceClass'
      Engine: postgres
      EngineVersion: '11.6'
      MasterUsername: !Ref 'DbUsername'
      MasterUserPassword: !Ref 'DbPassword'
      MultiAZ: false
      DBSubnetGroupName: !Ref DbSubnetGroup
      VPCSecurityGroups:
        - !Ref PrivateLoadBalancerSG

  PrimaryBucket:
    Type: AWS::S3::Bucket

  # This is a role which is used by the ECS tasks themselves.
  ECSTaskExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Statement:
          - Effect: Allow
            Principal:
              Service: [ecs-tasks.amazonaws.com]
            Action: ['sts:AssumeRole']
      Path: /
      Policies:
        - PolicyName: AmazonECSTaskExecutionRolePolicy
          PolicyDocument:
            Statement:
              - Effect: Allow
                Action:
                  # Allow the ECS Tasks to download images from ECR
                  - 'ecr:GetAuthorizationToken'
                  - 'ecr:BatchCheckLayerAvailability'
                  - 'ecr:GetDownloadUrlForLayer'
                  - 'ecr:BatchGetImage'

                  # Allow the ECS tasks to upload logs to CloudWatch
                  - 'logs:CreateLogStream'
                  - 'logs:CreateLogGroup'
                  - 'logs:PutLogEvents'
                Resource: '*'

  # The task definition. This is a simple metadata description of what
  # container to run, and what resource requirements it has.
  ApiTaskDefinition:
    Type: AWS::ECS::TaskDefinition
    DeletionPolicy: Delete
    Properties:
      Cpu: !Ref 'ApiCpu'
      Memory: !Ref 'ApiMemory'
      NetworkMode: awsvpc
      RequiresCompatibilities:
        - FARGATE
      ExecutionRoleArn: !Ref 'ECSTaskExecutionRole'
      ContainerDefinitions:
        - Name: api
          Cpu: !Ref 'ApiCpu'
          Memory: !Ref 'ApiMemory'
          LogConfiguration:
            LogDriver: awslogs
            Options:
              awslogs-create-group: true
              awslogs-region: !Ref AWS::Region
              awslogs-group: !Join ['-', [!Ref 'AWS::StackName', 'api']]
              awslogs-stream-prefix: api
          PortMappings:
            - ContainerPort: !Ref ApiPort
          Image:
            !Join [
              '',
              [!Ref 'AWS::AccountId', '.dkr.ecr.', !Ref 'AWS::Region', '.amazonaws.com/', !Ref 'ApiImageRepository'],
            ]
          Environment:
            - Name: APP_GRAPHQL_PORT
              Value: !Ref ApiPort
            - Name: LOG_LEVEL
              Value: debug
            - Name: APP_SESSION_SECRET
              Value: !Ref ApiSessionSecret
            - Name: APP_WEB_URI
              Value: !Join ['', ['http://', !GetAtt 'FrontendBucket.WebsiteURL']]
            - Name: CDN_DOMAIN_NAME
              Value: 'example.com'
            - Name: DB_HOST
              Value: !GetAtt Db.Endpoint.Address
            - Name: DB_NAME
              Value: !Ref DbName
            - Name: DB_PASSWORD
              Value: !Ref DbPassword
            - Name: DB_PORT
              Value: !GetAtt Db.Endpoint.Port
            - Name: DB_USERNAME
              Value: !Ref DbUsername
            - Name: NODE_ENV
              Value: production
            - Name: REDIS_HOST
              Value: !GetAtt ElasticacheCluster.RedisEndpoint.Address
            - Name: REDIS_PORT
              Value: !GetAtt ElasticacheCluster.RedisEndpoint.Port
            - Name: S3_BUCKET
              Value: !Ref PrimaryBucket
            - Name: S3_VIDEO_SRC_BUCKET
              Value: { Fn::ImportValue: !Sub '${VideoProcessingStack}:Source' }
            - Name: SQS_VIDEO_QUEUE_URL
              Value: { Fn::ImportValue: !Sub '${VideoProcessingStack}:SqsQueue' }
          Command:
            - api

  Cluster:
    Type: AWS::ECS::Cluster

  # Create a rule on the load balancer for routing traffic to the target group
  LoadBalancerRule:
    Type: AWS::ElasticLoadBalancingV2::ListenerRule
    Properties:
      Actions:
        - TargetGroupArn: !Ref ServerTargetGroup
          Type: 'forward'
      Conditions:
        - Field: path-pattern
          Values:
            - '*'
      ListenerArn: !Ref PublicLoadBalancerListener
      Priority: 1

  # A target group. This is used for keeping track of all the tasks, and
  # what IP addresses / port numbers they have. You can query it yourself,
  # to use the addresses yourself, but most often this target group is just
  # connected to an application load balancer, or network load balancer, so
  # it can automatically distribute traffic across all the targets.
  ServerTargetGroup:
    Type: AWS::ElasticLoadBalancingV2::TargetGroup
    Properties:
      Name: api
      HealthCheckIntervalSeconds: 20
      HealthCheckPort: !Ref ApiPort
      HealthCheckPath: /health
      HealthCheckProtocol: HTTP
      HealthCheckTimeoutSeconds: 10
      HealthyThresholdCount: 2
      TargetType: ip
      Port: !Ref ApiPort
      Protocol: HTTP
      UnhealthyThresholdCount: 2
      VpcId: !Ref VPC

  # The service. The service is a resource which allows you to run multiple
  # copies of a type of task, and gather up their logs and metrics, as well
  # as monitor the number of running tasks and replace any that have crashed
  ApiService:
    Type: AWS::ECS::Service
    DependsOn: LoadBalancerRule
    Properties:
      ServiceName: api
      Cluster: !Ref Cluster
      LaunchType: FARGATE
      DeploymentConfiguration:
        MaximumPercent: 200
        MinimumHealthyPercent: 100
      NetworkConfiguration:
        AwsvpcConfiguration:
          AssignPublicIp: ENABLED
          SecurityGroups:
            - !Ref FargateContainerSecurityGroup
          Subnets:
            - !Ref PublicSubnet1
            - !Ref PublicSubnet2
      TaskDefinition: !Ref ApiTaskDefinition
      LoadBalancers:
        - ContainerName: api
          ContainerPort: !Ref ApiPort
          TargetGroupArn: !Ref ServerTargetGroup

  # The task definition. This is a simple metadata description of what
  # container to run, and what resource requirements it has.
  WorkerTaskDefinition:
    Type: AWS::ECS::TaskDefinition
    DeletionPolicy: Delete
    Properties:
      Cpu: !Ref WorkerCpu
      Memory: !Ref WorkerMemory
      NetworkMode: awsvpc
      RequiresCompatibilities:
        - FARGATE
      ExecutionRoleArn: !Ref 'ECSTaskExecutionRole'
      ContainerDefinitions:
        - Name: worker
          Cpu: !Ref WorkerCpu
          Memory: !Ref WorkerMemory
          LogConfiguration:
            LogDriver: awslogs
            Options:
              awslogs-create-group: true
              awslogs-region: !Ref AWS::Region
              awslogs-group: !Join ['-', [!Ref 'AWS::StackName', 'worker']]
              awslogs-stream-prefix: ecs
          PortMappings:
            - ContainerPort: !Ref WorkerPort
          Image:
            !Join [
              '',
              [!Ref 'AWS::AccountId', '.dkr.ecr.', !Ref 'AWS::Region', '.amazonaws.com/', !Ref 'ApiImageRepository'],
            ]
          Environment:
            - Name: APP_GRAPHQL_PORT
              Value: !Ref ApiPort
            - Name: LOG_LEVEL
              Value: debug
            - Name: APP_SESSION_SECRET
              Value: !Ref ApiSessionSecret
            - Name: APP_WEB_URI
              Value: !Join ['', ['http://', !GetAtt 'FrontendBucket.WebsiteURL']]
            - Name: CDN_DOMAIN_NAME
              Value: 'example.com'
            - Name: DB_HOST
              Value: !GetAtt Db.Endpoint.Address
            - Name: DB_NAME
              Value: !Ref DbName
            - Name: DB_PASSWORD
              Value: !Ref DbPassword
            - Name: DB_PORT
              Value: !GetAtt Db.Endpoint.Port
            - Name: DB_USERNAME
              Value: !Ref DbUsername
            - Name: NODE_ENV
              Value: production
            - Name: REDIS_HOST
              Value: !GetAtt ElasticacheCluster.RedisEndpoint.Address
            - Name: REDIS_PORT
              Value: !GetAtt ElasticacheCluster.RedisEndpoint.Port
            - Name: S3_BUCKET
              Value: !Ref PrimaryBucket
            - Name: S3_VIDEO_SRC_BUCKET
              Value: { Fn::ImportValue: !Sub '${VideoProcessingStack}:Source' }
            - Name: SQS_VIDEO_QUEUE_URL
              Value: { Fn::ImportValue: !Sub '${VideoProcessingStack}:SqsQueue' }
          Command:
            - jobs

  # The service. The service is a resource which allows you to run multiple
  # copies of a type of task, and gather up their logs and metrics, as well
  # as monitor the number of running tasks and replace any that have crashed
  WorkerService:
    Type: AWS::ECS::Service
    Properties:
      ServiceName: worker
      Cluster: !Ref Cluster
      LaunchType: FARGATE
      DeploymentConfiguration:
        MaximumPercent: 200
        MinimumHealthyPercent: 100
      NetworkConfiguration:
        AwsvpcConfiguration:
          AssignPublicIp: ENABLED
          SecurityGroups:
            - !Ref FargateContainerSecurityGroup
          Subnets:
            - !Ref PublicSubnet1
            - !Ref PublicSubnet2
      TaskDefinition: !Ref WorkerTaskDefinition
