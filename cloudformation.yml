AWSTemplateFormatVersion: 2010-09-09
Description: A stack for deploying StringSync in AWS

Parameters:
  BranchName:
    Description: CodeCommit repository branch name
    Type: String
    Default: master

  DbName:
    Description: The database name
    Type: String
    MinLength: '1'
    MaxLength: '64'
    AllowedPattern: '[a-zA-Z][a-zA-Z0-9]*'
    ConstraintDescription: must begin with a letter and contain only alphanumeric
      characters.

  DbUsername:
    NoEcho: true
    Description: The database admin account username
    Type: String
    MinLength: '1'
    MaxLength: '16'
    AllowedPattern: '[a-zA-Z][a-zA-Z0-9]*'
    ConstraintDescription: must begin with a letter and contain only alphanumeric
      characters.

  DbPassword:
    NoEcho: true
    Description: The database admin account password
    Type: String
    MinLength: '1'
    MaxLength: '41'
    AllowedPattern: '[a-zA-Z0-9]+'
    ConstraintDescription: must contain only alphanumeric characters.

  DbAllocatedStorage:
    Default: '20'
    Description: The size of the database (Gb)
    Type: Number
    MinValue: '20'
    MaxValue: '1024'
    ConstraintDescription: must be between 5 and 1024Gb.

  DbInstanceClass:
    Description: The database instance type
    Type: String
    Default: db.t3.micro
    AllowedValues:
      - db.t3.micro
      - db.t3.small
      - db.t3.medium
      - db.t3.large
    ConstraintDescription: must select a valid database instance type.

  ApiCpu:
    Type: Number
    Default: '256'
    Description: How much CPU to give the container. 1024 is 1 CPU.x

  ApiMemory:
    Type: Number
    Default: '512'
    Description: How much memory in megabytes to give the container.

  ApiPort:
    Type: Number
    Default: '3000'
    Description: What port number the application inside the docker container is binding to.

  ApiSessionSecret:
    NoEcho: true
    Type: String
    Description: The secret to encrypt session data for the API.

  WorkerCpu:
    Type: Number
    Default: '256'
    Description: How much CPU to give the container. 1024 is 1 CPU.

  WorkerMemory:
    Type: Number
    Default: '512'
    Description: How much memory in megabytes to give the container.

  WorkerPort:
    Type: Number
    Default: '3000'
    Description: What port number the application inside the docker container is binding to.

  DomainName:
    Type: String
    Default: ''
    Description: The application naked domain name, e.g. example.com (not www.example.com)

  AdminEmail:
    Description: Email address for SNS notifications (subscribed users will receive ingest, publishing, and error notifications)
    Type: String
    AllowedPattern: "^[_A-Za-z0-9-\\+]+(\\.[_A-Za-z0-9-]+)*@[A-Za-z0-9-]+(\\.[A-Za-z0-9]+)*(\\.[A-Za-z]{2,})$"

  WorkflowTrigger:
    Description: How the workflow will be triggered (source video upload to S3 or source metadata file upload)
    Type: String
    Default: VideoFile
    AllowedValues:
      - VideoFile
      - MetadataFile

  Glacier:
    Description: If enabled, source assets will be tagged for archiving to Glacier or Glacier Deep Archive once the workflow is complete
    Type: String
    Default: DISABLED
    AllowedValues:
      - DISABLED
      - GLACIER
      - DEEP_ARCHIVE

  FrameCapture:
    Description: If enabled, frame capture is added to the job submitted to MediaConvert
    Type: String
    Default: No
    AllowedValues:
      - Yes
      - No

  EnableMediaPackage:
    Description: If enabled, MediaPackage VOD will be included in the workflow
    Type: String
    Default: No
    AllowedValues:
      - Yes
      - No

  EnableSns:
    Description: Enable Ingest and Publish email notifications, error messages are not afeected by this parameter.
    Type: String
    Default: Yes
    AllowedValues:
      - Yes
      - No

  EnableSqs:
    Description: Publish the workflow results to an SQS queue to injest upstream
    Type: String
    Default: Yes
    AllowedValues:
      - Yes
      - No

  AcceleratedTranscoding:
    Description: Enable accelerated transcoding in AWS Elemental MediaConvert. PREFERRED will only use acceleration if the input files is supported. ENABLED accleration is applied to all files (this will fail for unsupported file types) see MediaConvert Documentation for more detail https://docs.aws.amazon.com/mediaconvert/latest/ug/accelerated-transcoding.html
    Type: String
    Default: PREFERRED
    AllowedValues:
      - ENABLED
      - DISABLED
      - PREFERRED

Metadata:
  AWS::CloudFormation::Interface:
    ParameterGroups:
      - Label:
          default: 'Workflow'
        Parameters:
          - AdminEmail
          - WorkflowTrigger
          - Glacier
          - EnableSns
          - EnableSqs
      - Label:
          default: 'AWS Elemental MediaConvert'
        Parameters:
          - FrameCapture
          - AcceleratedTranscoding
      - Label:
          default: 'AWS Elemental MediaPackage'
        Parameters:
          - EnableMediaPackage
    ParameterLabels:
      AdminEmail:
        default: Notification email address
      Glacier:
        default: Archive source content
      WorkflowTrigger:
        default: Workflow trigger
      FrameCapture:
        default: Enable Frame Capture
      EnableMediaPackage:
        default: Enable MediaPackage
      AcceleratedTranscoding:
        default: Accelerated Transcoding
      EnableSns:
        default: Enable SNS Notifications
      EnableSqs:
        default: Enable SQS Messaging

Mappings:
  # Hard values for the subnet masks. These masks define
  # the range of internal IP addresses that can be assigned.
  # The VPC can have all IP's from 10.0.0.0 to 10.0.255.255
  # There are two subnets which cover the ranges:
  #
  # 10.0.0.0 - 10.0.0.255
  # 10.0.1.0 - 10.0.1.255
  #
  # If you need more IP addresses (perhaps you have so many
  # instances that you run out) then you can customize these
  # ranges to add more
  SubnetConfig:
    VPC:
      CIDR: '10.0.0.0/16'
    Public1:
      CIDR: '10.0.0.0/24'
    Public2:
      CIDR: '10.0.1.0/24'
    Private1:
      CIDR: '10.0.2.0/24'
    Private2:
      CIDR: '10.0.3.0/24'

  SourceCode:
    General:
      S3Bucket: 'solutions'
      KeyPrefix: 'video-on-demand-on-aws/v5.1.0'

  AnonymousData:
    SendAnonymousData:
      Data: No

Conditions:
  Metrics: !Equals [!FindInMap [AnonymousData, SendAnonymousData, Data], Yes]
  IsMediaPackageEnabled: !Equals [!Ref EnableMediaPackage, Yes]

Resources:
  CodePipelineArtifactStore:
    DeletionPolicy: Delete
    Type: AWS::S3::Bucket

  MediaBucket:
    Type: AWS::S3::Bucket
    DeletionPolicy: Delete

  MediaBucketOriginAccessIdentity:
    Type: AWS::CloudFront::CloudFrontOriginAccessIdentity
    Properties:
      CloudFrontOriginAccessIdentityConfig:
        Comment: !Sub access-identity-${MediaBucket}

  MediaBucketPolicy:
    Type: AWS::S3::BucketPolicy
    Properties:
      Bucket: !Ref MediaBucket
      PolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              AWS: !Sub arn:aws:iam::cloudfront:user/CloudFront Origin Access Identity ${MediaBucketOriginAccessIdentity}
            Action: s3:GetObject
            Resource: !Sub arn:aws:s3:::${MediaBucket}/*

  MediaDistributionCachePolicy:
    Type: AWS::CloudFront::CachePolicy
    Properties:
      CachePolicyConfig:
        Name: MediaDistributionCachePolicy
        Comment: Cache policy for the web distribution
        DefaultTTL: 1800
        MinTTL: 1800
        MaxTTL: 3600
        ParametersInCacheKeyAndForwardedToOrigin:
          CookiesConfig:
            CookieBehavior: none
          EnableAcceptEncodingGzip: false
          HeadersConfig:
            HeaderBehavior: none
          QueryStringsConfig:
            QueryStringBehavior: none

  MediaDistribution:
    Type: AWS::CloudFront::Distribution
    Properties:
      DistributionConfig:
        Enabled: true
        Comment: Serves media saved in the media bucket
        PriceClass: PriceClass_All
        Aliases:
          - !Sub media.${DomainName}
        ViewerCertificate:
          AcmCertificateArn: !Ref DomainCertificate
          SslSupportMethod: sni-only
        Origins:
          - DomainName: !GetAtt MediaBucket.DomainName
            Id: S3-media
            S3OriginConfig:
              OriginAccessIdentity: !Sub origin-access-identity/cloudfront/${MediaBucketOriginAccessIdentity}
        DefaultCacheBehavior:
          TargetOriginId: S3-media
          ViewerProtocolPolicy: redirect-to-https
          AllowedMethods:
            - HEAD
            - GET
            - OPTIONS
          CachePolicyId: !Ref MediaDistributionCachePolicy

  WebBucket:
    DeletionPolicy: Delete
    Type: AWS::S3::Bucket

  WebBucketOriginAccessIdentity:
    Type: AWS::CloudFront::CloudFrontOriginAccessIdentity
    Properties:
      CloudFrontOriginAccessIdentityConfig:
        Comment: !Sub access-identity-${WebBucket}

  WebBucketPolicy:
    Type: AWS::S3::BucketPolicy
    Properties:
      Bucket: !Ref WebBucket
      PolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              AWS: !Sub arn:aws:iam::cloudfront:user/CloudFront Origin Access Identity ${WebBucketOriginAccessIdentity}
            Action: s3:GetObject
            Resource: !Sub arn:aws:s3:::${WebBucket}/*

  WebDistributionCachePolicy:
    Type: AWS::CloudFront::CachePolicy
    Properties:
      CachePolicyConfig:
        Name: WebDistributionCachePolicy
        Comment: Cache policy for the web distribution
        DefaultTTL: 1800
        MinTTL: 1800
        MaxTTL: 3600
        ParametersInCacheKeyAndForwardedToOrigin:
          CookiesConfig:
            CookieBehavior: none
          EnableAcceptEncodingGzip: false
          HeadersConfig:
            HeaderBehavior: none
          QueryStringsConfig:
            QueryStringBehavior: none

  WebDistribution:
    Type: AWS::CloudFront::Distribution
    Properties:
      DistributionConfig:
        Enabled: true
        Comment: Serves the application frontend
        CustomErrorResponses:
          - ErrorCode: 403
            ResponseCode: 200
            ResponsePagePath: /index.html
          - ErrorCode: 404
            ResponseCode: 200
            ResponsePagePath: /index.html
        PriceClass: PriceClass_All
        Aliases:
          - !Ref DomainName
        ViewerCertificate:
          AcmCertificateArn: !Ref DomainCertificate
          SslSupportMethod: sni-only
        Origins:
          - DomainName: !GetAtt WebBucket.DomainName
            Id: S3-web
            S3OriginConfig:
              OriginAccessIdentity: !Sub origin-access-identity/cloudfront/${WebBucketOriginAccessIdentity}
        DefaultRootObject: index.html
        DefaultCacheBehavior:
          TargetOriginId: S3-web
          ViewerProtocolPolicy: redirect-to-https
          AllowedMethods:
            - HEAD
            - GET
            - OPTIONS
          CachePolicyId: !Ref WebDistributionCachePolicy

  WebWWWRedirectBucket:
    DeletionPolicy: Delete
    Type: AWS::S3::Bucket
    Properties:
      WebsiteConfiguration:
        RedirectAllRequestsTo:
          HostName: !Ref DomainName
          Protocol: http

  WebWWWRedirectBucketOriginAccessIdentity:
    Type: AWS::CloudFront::CloudFrontOriginAccessIdentity
    Properties:
      CloudFrontOriginAccessIdentityConfig:
        Comment: !Sub access-identity-${WebWWWRedirectBucket}

  WebWWWRedirectDistribution:
    Type: AWS::CloudFront::Distribution
    Properties:
      DistributionConfig:
        Enabled: true
        Comment: !Sub Redirects to ${DomainName}
        PriceClass: PriceClass_All
        Aliases:
          - !Sub www.${DomainName}
        ViewerCertificate:
          AcmCertificateArn: !Ref DomainCertificate
          SslSupportMethod: sni-only
        Origins:
          - DomainName: !Select
              - 1
              - !Split
                - '//'
                - !GetAtt WebWWWRedirectBucket.WebsiteURL
            Id: S3-www-web
            CustomOriginConfig:
              OriginProtocolPolicy: https-only
        DefaultCacheBehavior:
          TargetOriginId: S3-www-web
          ViewerProtocolPolicy: redirect-to-https
          AllowedMethods:
            - HEAD
            - GET
            - OPTIONS
          CachePolicyId: !Ref WebDistributionCachePolicy

  HostedZone:
    Type: AWS::Route53::HostedZone
    Properties:
      Name: !Ref DomainName

  DNS:
    Type: AWS::Route53::RecordSetGroup
    Properties:
      HostedZoneId: !Ref HostedZone
      RecordSets:
        - Name: !Ref DomainName
          Type: A
          AliasTarget:
            HostedZoneId: Z2FDTNDATAQYW2
            DNSName: !GetAtt WebDistribution.DomainName
        - Name: !Sub www.${DomainName}
          Type: A
          AliasTarget:
            HostedZoneId: Z2FDTNDATAQYW2
            DNSName: !GetAtt WebWWWRedirectDistribution.DomainName
        - Name: !Sub media.${DomainName}
          Type: A
          AliasTarget:
            HostedZoneId: Z2FDTNDATAQYW2
            DNSName: !GetAtt MediaDistribution.DomainName
        - Name: !Sub api.${DomainName}
          Type: A
          AliasTarget:
            HostedZoneId: !GetAtt PublicLoadBalancer.CanonicalHostedZoneID
            DNSName: !GetAtt PublicLoadBalancer.DNSName

  DomainCertificate:
    Type: AWS::CertificateManager::Certificate
    Properties:
      DomainName: !Ref DomainName
      SubjectAlternativeNames:
        - !Sub '*.${DomainName}'
      ValidationMethod: DNS

  CodeCommitRepository:
    Type: AWS::CodeCommit::Repository
    Properties:
      RepositoryName: !Ref AWS::StackName

  ApiImageRepository:
    Type: AWS::ECR::Repository
    DeletionPolicy: Delete
    Properties:
      LifecyclePolicy:
        LifecyclePolicyText: |
          {
            "rules": [
              {
                "rulePriority": 1,
                "description": "Keep only one untagged image, expire all others",
                "selection": {
                  "tagStatus": "untagged",
                  "countType": "imageCountMoreThan",
                  "countNumber": 1
                },
                "action": {
                  "type": "expire"
                }
              }
            ]
          }

  CmdImageRepository:
    Type: AWS::ECR::Repository
    DeletionPolicy: Delete
    Properties:
      LifecyclePolicy:
        LifecyclePolicyText: |
          {
            "rules": [
              {
                "rulePriority": 1,
                "description": "Keep only one untagged image, expire all others",
                "selection": {
                  "tagStatus": "untagged",
                  "countType": "imageCountMoreThan",
                  "countNumber": 1
                },
                "action": {
                  "type": "expire"
                }
              }
            ]
          }

  CodeBuildServiceRole:
    Type: AWS::IAM::Role
    Properties:
      Path: /
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - codebuild.amazonaws.com
            Action: sts:AssumeRole
      Policies:
        - PolicyName: AWS-CodeBuild-Service-3
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - 'logs:*'
                  - 'ec2:*'
                  - 's3:*'
                  - 'ecr:*'
                  - 'cloudwatch:*'
                Resource: '*'

  CodeBuildSecretsBucket:
    Type: AWS::S3::Bucket
    DeletionPolicy: Delete

  CloudWatchEventRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - events.amazonaws.com
            Action: sts:AssumeRole
      Path: /
      Policies:
        - PolicyName: cwe-pipeline-execution
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action: codepipeline:StartPipelineExecution
                Resource: '*'

  CloudWatchEventRule:
    Type: AWS::Events::Rule
    Properties:
      EventPattern:
        source:
          - aws.codecommit
        detail-type:
          - 'CodeCommit Repository State Change'
        resources:
          - !GetAtt CodeCommitRepository.Arn
        detail:
          event:
            - referenceCreated
            - referenceUpdated
          referenceType:
            - branch
          referenceName:
            - !Ref BranchName
      Targets:
        - Arn:
            !Join [
              '',
              ['arn:aws:codepipeline:', !Ref 'AWS::Region', ':', !Ref 'AWS::AccountId', ':', !Ref CodePipeline],
            ]
          RoleArn: !GetAtt CloudWatchEventRole.Arn
          Id: !Ref AWS::StackName

  CodePipelineServiceRole:
    Type: AWS::IAM::Role
    Properties:
      Path: /
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - codepipeline.amazonaws.com
            Action: sts:AssumeRole
      Policies:
        - PolicyName: AWS-CodePipeline-Service-3
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - 'codecommit:CancelUploadArchive'
                  - 'codecommit:GetBranch'
                  - 'codecommit:GetCommit'
                  - 'codecommit:GetUploadArchiveStatus'
                  - 'codecommit:UploadArchive'
                Resource: '*'
              - Effect: Allow
                Action:
                  - 'codedeploy:CreateDeployment'
                  - 'codedeploy:GetApplicationRevision'
                  - 'codedeploy:GetDeployment'
                  - 'codedeploy:GetDeploymentConfig'
                  - 'codedeploy:RegisterApplicationRevision'
                Resource: '*'
              - Effect: Allow
                Action:
                  - 'codebuild:BatchGetBuilds'
                  - 'codebuild:StartBuild'
                Resource: '*'
              - Effect: Allow
                Action:
                  - 'devicefarm:ListProjects'
                  - 'devicefarm:ListDevicePools'
                  - 'devicefarm:GetRun'
                  - 'devicefarm:GetUpload'
                  - 'devicefarm:CreateUpload'
                  - 'devicefarm:ScheduleRun'
                Resource: '*'
              - Effect: Allow
                Action:
                  - 'lambda:InvokeFunction'
                  - 'lambda:ListFunctions'
                Resource: '*'
              - Effect: Allow
                Action:
                  - 'iam:PassRole'
                Resource: '*'
              - Effect: Allow
                Action:
                  - 'elasticbeanstalk:*'
                  - 'ec2:*'
                  - 'elasticloadbalancing:*'
                  - 'autoscaling:*'
                  - 'cloudwatch:*'
                  - 's3:*'
                  - 'sns:*'
                  - 'cloudformation:*'
                  - 'rds:*'
                  - 'sqs:*'
                  - 'ecs:*'
                Resource: '*'

  CodeBuildCacheBucket:
    Type: AWS::S3::Bucket

  CodeBuildProject:
    Type: AWS::CodeBuild::Project
    Properties:
      Name: !Ref AWS::StackName
      ServiceRole: !GetAtt CodeBuildServiceRole.Arn
      TimeoutInMinutes: 30
      Cache:
        Type: S3
        Location: !Ref CodeBuildCacheBucket
        Modes:
          - LOCAL_DOCKER_LAYER_CACHE
          - LOCAL_CUSTOM_CACHE
      Artifacts:
        Type: CODEPIPELINE
      Environment:
        Type: LINUX_CONTAINER
        ComputeType: BUILD_GENERAL1_SMALL
        Image: aws/codebuild/standard:4.0
        PrivilegedMode: true
        EnvironmentVariables:
          - Name: AWS_ACCOUNT_ID
            Type: PLAINTEXT
            Value: !Ref AWS::AccountId
          - Name: IMAGE_REPO_NAME
            Type: PLAINTEXT
            Value: !Ref ApiImageRepository
          - Name: CMD_IMAGE_REPO_NAME
            Type: PLAINTEXT
            Value: !Ref CmdImageRepository
          - Name: REACT_APP_SERVER_URI
            Type: PLAINTEXT
            Value: !Sub https://api.${DomainName}
          - Name: DOMAIN_NAME
            Type: PLAINTEXT
            Value: !Ref DomainName
          - Name: S3_SECRETS_BUCKET
            Type: PLAINTEXT
            Value: !Ref CodeBuildSecretsBucket
      Source:
        Type: CODEPIPELINE

  CodePipeline:
    Type: AWS::CodePipeline::Pipeline
    Properties:
      RoleArn: !GetAtt CodePipelineServiceRole.Arn
      RestartExecutionOnUpdate: false
      ArtifactStore:
        Type: S3
        Location: !Ref CodePipelineArtifactStore
      Stages:
        - Name: Source
          Actions:
            - Name: SourceAction
              RunOrder: 1
              ActionTypeId:
                Category: Source
                Owner: AWS
                Provider: CodeCommit
                Version: '1'
              OutputArtifacts:
                - Name: SourceOutput
              Configuration:
                RepositoryName: !Ref AWS::StackName
                BranchName: !Ref BranchName
                PollForSourceChanges: false
        - Name: Build
          Actions:
            - Name: BuildAction
              RunOrder: 2
              ActionTypeId:
                Category: Build
                Owner: AWS
                Provider: CodeBuild
                Version: '1'
              InputArtifacts:
                - Name: SourceOutput
              OutputArtifacts:
                - Name: BuildImageDefinitionsOutput
                - Name: BuildWebOutput
              Configuration:
                ProjectName: !Ref CodeBuildProject
                PrimarySource: SourceOutput
        - Name: Deploy
          Actions:
            - Name: DeployApi
              RunOrder: 3
              ActionTypeId:
                Category: Deploy
                Owner: AWS
                Provider: ECS
                Version: '1'
              InputArtifacts:
                - Name: BuildImageDefinitionsOutput
              Configuration:
                ClusterName: !Ref Cluster
                ServiceName: !Ref ApiService
                FileName: imagedefinitions.api.json
            - Name: DeployWorker
              RunOrder: 3
              ActionTypeId:
                Category: Deploy
                Owner: AWS
                Provider: ECS
                Version: '1'
              InputArtifacts:
                - Name: BuildImageDefinitionsOutput
              Configuration:
                ClusterName: !Ref Cluster
                ServiceName: !Ref WorkerService
                FileName: imagedefinitions.worker.json
            - Name: DeployWeb
              RunOrder: 3
              ActionTypeId:
                Category: Deploy
                Owner: AWS
                Provider: S3
                Version: '1'
              InputArtifacts:
                - Name: BuildWebOutput
              Configuration:
                BucketName: !Ref WebBucket
                Extract: true

  # VPC in which containers will be networked.
  # It has two public subnets
  # We distribute the subnets across the first two available subnets
  # for the region, for high availability.
  VPC:
    Type: AWS::EC2::VPC
    Properties:
      EnableDnsSupport: true
      EnableDnsHostnames: true

      CidrBlock: !FindInMap ['SubnetConfig', 'VPC', 'CIDR']

  # Two public subnets, where containers can have public IP addresses
  PublicSubnet1:
    Type: AWS::EC2::Subnet
    Properties:
      AvailabilityZone: !Select [0, Fn::GetAZs: { Ref: 'AWS::Region' }]
      VpcId: !Ref 'VPC'
      CidrBlock: !FindInMap ['SubnetConfig', 'Public1', 'CIDR']
      MapPublicIpOnLaunch: true

  PublicSubnet2:
    Type: AWS::EC2::Subnet
    Properties:
      AvailabilityZone: !Select [1, Fn::GetAZs: { Ref: 'AWS::Region' }]
      VpcId: !Ref 'VPC'
      CidrBlock: !FindInMap ['SubnetConfig', 'Public2', 'CIDR']
      MapPublicIpOnLaunch: true

  # Two private subnets where containers will only have private
  # IP addresses, and will only be reachable by other members of the
  # VPC
  PrivateSubnet1:
    Type: AWS::EC2::Subnet
    Properties:
      AvailabilityZone: !Select [0, Fn::GetAZs: { Ref: 'AWS::Region' }]
      VpcId: !Ref 'VPC'
      CidrBlock: !FindInMap ['SubnetConfig', 'Private1', 'CIDR']
  PrivateSubnet2:
    Type: AWS::EC2::Subnet
    Properties:
      AvailabilityZone: !Select [1, Fn::GetAZs: { Ref: 'AWS::Region' }]
      VpcId: !Ref 'VPC'
      CidrBlock: !FindInMap ['SubnetConfig', 'Private2', 'CIDR']

  # Setup networking resources for the public subnets. Containers
  # in the public subnets have public IP addresses and the routing table
  # sends network traffic via the internet gateway.
  InternetGateway:
    Type: AWS::EC2::InternetGateway
  GatewayAttachement:
    Type: AWS::EC2::VPCGatewayAttachment
    Properties:
      VpcId: !Ref 'VPC'
      InternetGatewayId: !Ref 'InternetGateway'
  PublicRouteTable:
    Type: AWS::EC2::RouteTable
    Properties:
      VpcId: !Ref 'VPC'
  PublicRoute:
    Type: AWS::EC2::Route
    DependsOn: GatewayAttachement
    Properties:
      RouteTableId: !Ref 'PublicRouteTable'
      DestinationCidrBlock: '0.0.0.0/0'
      GatewayId: !Ref 'InternetGateway'
  PublicSubnet1RouteTableAssociation:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      SubnetId: !Ref PublicSubnet1
      RouteTableId: !Ref PublicRouteTable
  PublicSubnet2RouteTableAssociation:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      SubnetId: !Ref PublicSubnet2
      RouteTableId: !Ref PublicRouteTable

  # Setup networking resources for the private subnets. Containers
  # in these subnets have only private IP addresses, and must use a NAT
  # gateway to talk to the internet. We launch two NAT gateways, one for
  # each private subnet.

  # UNCOMMENT IF ACCESS FROM A PRIVATE SUBNET TO THE INTERNET IS NEEDED

  # NatGateway1Attachment:
  #   Type: AWS::EC2::EIP
  #   DependsOn: GatewayAttachement
  #   Properties:
  #     Domain: vpc

  # NatGateway2Attachment:
  #   Type: AWS::EC2::EIP
  #   DependsOn: GatewayAttachement
  #   Properties:
  #     Domain: vpc

  # NatGateway1:
  #   Type: AWS::EC2::NatGateway
  #   Properties:
  #     AllocationId: !GetAtt NatGateway1Attachment.AllocationId
  #     SubnetId: !Ref PublicSubnet1

  # NatGateway2:
  #   Type: AWS::EC2::NatGateway
  #   Properties:
  #     AllocationId: !GetAtt NatGateway2Attachment.AllocationId
  #     SubnetId: !Ref PublicSubnet2

  PrivateRouteTable1:
    Type: AWS::EC2::RouteTable
    Properties:
      VpcId: !Ref 'VPC'

  # PrivateRoute1:
  #   Type: AWS::EC2::Route
  #   Properties:
  #     RouteTableId: !Ref PrivateRouteTable1
  #     DestinationCidrBlock: 0.0.0.0/0
  #     NatGatewayId: !Ref NatGateway1

  PrivateRouteTable1Association:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      RouteTableId: !Ref PrivateRouteTable1
      SubnetId: !Ref PrivateSubnet1

  PrivateRouteTable2:
    Type: AWS::EC2::RouteTable
    Properties:
      VpcId: !Ref 'VPC'

  # PrivateRoute2:
  #   Type: AWS::EC2::Route
  #   Properties:
  #     RouteTableId: !Ref PrivateRouteTable2
  #     DestinationCidrBlock: 0.0.0.0/0
  #     NatGatewayId: !Ref NatGateway2

  PrivateRouteTable2Association:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      RouteTableId: !Ref PrivateRouteTable2
      SubnetId: !Ref PrivateSubnet2

  # A security group for the containers we will run in Fargate.
  # Three rules, allowing network traffic from a public facing load
  # balancer, a private internal load balancer, and from other members
  # of the security group.
  #
  # Remove any of the following ingress rules that are not needed.
  FargateContainerSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: Access to the Fargate containers
      VpcId: !Ref 'VPC'
  EcsSecurityGroupIngressFromPublicALB:
    Type: AWS::EC2::SecurityGroupIngress
    Properties:
      Description: Ingress from the public ALB
      GroupId: !Ref 'FargateContainerSecurityGroup'
      IpProtocol: '-1'
      SourceSecurityGroupId: !Ref 'PublicLoadBalancerSG'
  EcsSecurityGroupIngressFromPrivateALB:
    Type: AWS::EC2::SecurityGroupIngress
    Properties:
      Description: Ingress from the private ALB
      GroupId: !Ref 'FargateContainerSecurityGroup'
      IpProtocol: '-1'
      SourceSecurityGroupId: !Ref 'PrivateLoadBalancerSG'
  EcsSecurityGroupIngressFromSelf:
    Type: AWS::EC2::SecurityGroupIngress
    Properties:
      Description: Ingress from other containers in the same security group
      GroupId: !Ref 'FargateContainerSecurityGroup'
      IpProtocol: '-1'
      SourceSecurityGroupId: !Ref 'FargateContainerSecurityGroup'

  # A public facing load balancer, this is used for accepting traffic from the public
  # internet and directing it to public facing microservices
  PublicLoadBalancerSG:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: Access to the public facing load balancer
      VpcId: !Ref 'VPC'
      SecurityGroupIngress:
        # Allow access to ALB from anywhere on the internet
        - CidrIp: 0.0.0.0/0
          IpProtocol: '-1'
  PublicLoadBalancer:
    Type: AWS::ElasticLoadBalancingV2::LoadBalancer
    Properties:
      Scheme: internet-facing
      LoadBalancerAttributes:
        - Key: idle_timeout.timeout_seconds
          Value: '30'
      Subnets:
        # The load balancer is placed into the public subnets, so that traffic
        # from the internet can reach the load balancer directly via the internet gateway
        - !Ref PublicSubnet1
        - !Ref PublicSubnet2
      SecurityGroups: [!Ref PublicLoadBalancerSG]
  # A dummy target group is used to setup the ALB to just drop traffic
  # initially, before any real service target groups have been added.
  DummyTargetGroupPublic:
    Type: AWS::ElasticLoadBalancingV2::TargetGroup
    Properties:
      HealthCheckIntervalSeconds: 6
      HealthCheckPath: /
      HealthCheckProtocol: HTTP
      HealthCheckTimeoutSeconds: 5
      HealthyThresholdCount: 2
      Name: !Join ['-', [!Ref 'AWS::StackName', 'drop-1']]
      Port: 80
      Protocol: HTTP
      UnhealthyThresholdCount: 2
      VpcId: !Ref 'VPC'

  PublicLoadBalancerHttpListener:
    Type: AWS::ElasticLoadBalancingV2::Listener
    Properties:
      Port: 80
      Protocol: HTTP
      LoadBalancerArn: !Ref PublicLoadBalancer
      DefaultActions:
        - Type: redirect
          RedirectConfig:
            Protocol: HTTPS
            StatusCode: 'HTTP_301'
            Port: '443'

  PublicLoadBalancerHttpsListener:
    Type: AWS::ElasticLoadBalancingV2::Listener
    Properties:
      Port: 443
      Protocol: HTTPS
      LoadBalancerArn: !Ref PublicLoadBalancer
      Certificates:
        - CertificateArn: !Ref DomainCertificate
      DefaultActions:
        - Type: forward
          TargetGroupArn: !Ref ServerTargetGroup

  # An internal load balancer, this would be used for a service that is not
  # directly accessible to the public, but instead should only receive traffic
  # from your other services.
  PrivateLoadBalancerSG:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: Access to the internal load balancer
      VpcId: !Ref 'VPC'
  PrivateLoadBalancerIngressFromECS:
    Type: AWS::EC2::SecurityGroupIngress
    Properties:
      Description: Only accept traffic from a container in the fargate container security group
      GroupId: !Ref 'PrivateLoadBalancerSG'
      IpProtocol: -1
      SourceSecurityGroupId: !Ref 'FargateContainerSecurityGroup'
  PrivateLoadBalancer:
    Type: AWS::ElasticLoadBalancingV2::LoadBalancer
    Properties:
      Scheme: internal
      LoadBalancerAttributes:
        - Key: idle_timeout.timeout_seconds
          Value: '30'
      Subnets:
        # This load balancer is put into the private subnet, so that there is no
        # route for the public to even be able to access the private load balancer.
        - !Ref PrivateSubnet1
        - !Ref PrivateSubnet2
      SecurityGroups: [!Ref 'PrivateLoadBalancerSG']
  # This dummy target group is used to setup the ALB to just drop traffic
  # initially, before any real service target groups have been added.
  DummyTargetGroupPrivate:
    Type: AWS::ElasticLoadBalancingV2::TargetGroup
    Properties:
      HealthCheckIntervalSeconds: 6
      HealthCheckPath: /
      HealthCheckProtocol: HTTP
      HealthCheckTimeoutSeconds: 5
      HealthyThresholdCount: 2
      Name: !Join ['-', [!Ref 'AWS::StackName', 'drop-2']]
      Port: 80
      Protocol: HTTP
      UnhealthyThresholdCount: 2
      VpcId: !Ref 'VPC'
  PrivateLoadBalancerListener:
    Type: AWS::ElasticLoadBalancingV2::Listener
    DependsOn:
      - PrivateLoadBalancer
    Properties:
      DefaultActions:
        - TargetGroupArn: !Ref 'DummyTargetGroupPrivate'
          Type: 'forward'
      LoadBalancerArn: !Ref 'PrivateLoadBalancer'
      Port: 80
      Protocol: HTTP

  # This is an IAM role which authorizes ECS to manage resources on your
  # account on your behalf, such as updating your load balancer with the
  # details of where your containers are, so that traffic can reach your
  # containers.
  ECSRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Statement:
          - Effect: Allow
            Principal:
              Service: [ecs.amazonaws.com]
            Action: ['sts:AssumeRole']
      Path: /
      Policies:
        - PolicyName: ecs-service
          PolicyDocument:
            Statement:
              - Effect: Allow
                Action:
                  # Rules which allow ECS to attach network interfaces to instances
                  # on your behalf in order for awsvpc networking mode to work right
                  - 'ec2:AttachNetworkInterface'
                  - 'ec2:CreateNetworkInterface'
                  - 'ec2:CreateNetworkInterfacePermission'
                  - 'ec2:DeleteNetworkInterface'
                  - 'ec2:DeleteNetworkInterfacePermission'
                  - 'ec2:Describe*'
                  - 'ec2:DetachNetworkInterface'

                  # Rules which allow ECS to update load balancers on your behalf
                  # with the information sabout how to send traffic to your containers
                  - 'elasticloadbalancing:DeregisterInstancesFromLoadBalancer'
                  - 'elasticloadbalancing:DeregisterTargets'
                  - 'elasticloadbalancing:Describe*'
                  - 'elasticloadbalancing:RegisterInstancesWithLoadBalancer'
                  - 'elasticloadbalancing:RegisterTargets'
                Resource: '*'

  ElasticacheSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: Access to the Elasticache service.
      VpcId: !Ref 'VPC'
  ElasticacheSecurityGroupIngressFromFargate:
    Type: AWS::EC2::SecurityGroupIngress
    Properties:
      Description: Ingress from Fargate Containers
      GroupId: !Ref 'ElasticacheSecurityGroup'
      IpProtocol: '-1'
      SourceSecurityGroupId: !Ref 'FargateContainerSecurityGroup'
  ElasticacheSubnetGroup:
    Type: 'AWS::ElastiCache::SubnetGroup'
    Properties:
      Description: Cache Subnet Group
      SubnetIds:
        - !Ref PrivateSubnet1
        - !Ref PrivateSubnet2
  ElasticacheCluster:
    Type: AWS::ElastiCache::CacheCluster
    Properties:
      Engine: redis
      EngineVersion: '5.0.0'
      CacheNodeType: cache.t2.micro
      NumCacheNodes: 1
      CacheSubnetGroupName: !Ref ElasticacheSubnetGroup
      VpcSecurityGroupIds:
        - !GetAtt ElasticacheSecurityGroup.GroupId

  DbSubnetGroup:
    Type: AWS::RDS::DBSubnetGroup
    Properties:
      DBSubnetGroupDescription: DB subnet group for the master DB
      SubnetIds:
        - !Ref PrivateSubnet1
        - !Ref PrivateSubnet2

  Db:
    Type: AWS::RDS::DBInstance
    DeletionPolicy: Snapshot
    Properties:
      DBName: !Ref 'DbName'
      AllocatedStorage: !Ref 'DbAllocatedStorage'
      DBInstanceClass: !Ref 'DbInstanceClass'
      Engine: postgres
      EngineVersion: '11.6'
      MasterUsername: !Ref 'DbUsername'
      MasterUserPassword: !Ref 'DbPassword'
      MultiAZ: false
      DBSubnetGroupName: !Ref DbSubnetGroup
      VPCSecurityGroups:
        - !Ref PrivateLoadBalancerSG

  # This is a role which is used by the ECS tasks themselves.
  ECSTaskExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Statement:
          - Effect: Allow
            Principal:
              Service: [ecs-tasks.amazonaws.com]
            Action: ['sts:AssumeRole']
      Path: /
      Policies:
        - PolicyName: AmazonECSTaskExecutionRolePolicy
          PolicyDocument:
            Statement:
              - Effect: Allow
                Action:
                  # Allow the ECS Tasks to download images from ECR
                  - 'ecr:GetAuthorizationToken'
                  - 'ecr:BatchCheckLayerAvailability'
                  - 'ecr:GetDownloadUrlForLayer'
                  - 'ecr:BatchGetImage'

                  # Allow the ECS tasks to upload logs to CloudWatch
                  - 'logs:CreateLogStream'
                  - 'logs:CreateLogGroup'
                  - 'logs:PutLogEvents'
                Resource: '*'

  # The task definition. This is a simple metadata description of what
  # container to run, and what resource requirements it has.
  ApiTaskDefinition:
    Type: AWS::ECS::TaskDefinition
    DeletionPolicy: Delete
    Properties:
      Cpu: !Ref 'ApiCpu'
      Memory: !Ref 'ApiMemory'
      NetworkMode: awsvpc
      RequiresCompatibilities:
        - FARGATE
      ExecutionRoleArn: !Ref 'ECSTaskExecutionRole'
      ContainerDefinitions:
        - Name: api
          Cpu: !Ref 'ApiCpu'
          Memory: !Ref 'ApiMemory'
          LogConfiguration:
            LogDriver: awslogs
            Options:
              awslogs-create-group: true
              awslogs-region: !Ref AWS::Region
              awslogs-group: !Sub /aws/ecs/${AWS::StackName}-api
              awslogs-stream-prefix: !Ref AWS::StackName
          PortMappings:
            - ContainerPort: !Ref ApiPort
          Image:
            !Join [
              '',
              [!Ref 'AWS::AccountId', '.dkr.ecr.', !Ref 'AWS::Region', '.amazonaws.com/', !Ref 'ApiImageRepository'],
            ]
          Environment:
            - Name: APP_GRAPHQL_PORT
              Value: !Ref ApiPort
            - Name: LOG_LEVEL
              Value: debug
            - Name: APP_SESSION_SECRET
              Value: !Ref ApiSessionSecret
            - Name: APP_WEB_URI
              Value: !Sub https://${DomainName}
            - Name: CDN_DOMAIN_NAME
              Value: !GetAtt WebDistribution.DomainName
            - Name: DB_HOST
              Value: !GetAtt Db.Endpoint.Address
            - Name: DB_NAME
              Value: !Ref DbName
            - Name: DB_PASSWORD
              Value: !Ref DbPassword
            - Name: DB_PORT
              Value: !GetAtt Db.Endpoint.Port
            - Name: DB_USERNAME
              Value: !Ref DbUsername
            - Name: NODE_ENV
              Value: production
            - Name: REDIS_HOST
              Value: !GetAtt ElasticacheCluster.RedisEndpoint.Address
            - Name: REDIS_PORT
              Value: !GetAtt ElasticacheCluster.RedisEndpoint.Port
            - Name: S3_BUCKET
              Value: !Ref MediaBucket
            - Name: S3_VIDEO_SRC_BUCKET
              Value: !Ref Source
            - Name: SQS_VIDEO_QUEUE_URL
              Value: !Ref SqsQueue
          Command:
            - api

  DbMigrateTaskDefinition:
    Type: AWS::ECS::TaskDefinition
    DeletionPolicy: Delete
    Properties:
      Cpu: '256'
      Memory: '512'
      NetworkMode: awsvpc
      RequiresCompatibilities:
        - FARGATE
      ExecutionRoleArn: !Ref 'ECSTaskExecutionRole'
      ContainerDefinitions:
        - Name: db-migrate
          Cpu: 256
          Memory: 512
          LogConfiguration:
            LogDriver: awslogs
            Options:
              awslogs-create-group: true
              awslogs-region: !Ref AWS::Region
              awslogs-group: !Sub /aws/ecs/${AWS::StackName}-db-migrate
              awslogs-stream-prefix: !Ref AWS::StackName
          Image:
            !Join [
              '',
              [!Ref 'AWS::AccountId', '.dkr.ecr.', !Ref 'AWS::Region', '.amazonaws.com/', !Ref 'CmdImageRepository'],
            ]
          Environment:
            - Name: DB_HOST
              Value: !GetAtt Db.Endpoint.Address
            - Name: DB_NAME
              Value: !Ref DbName
            - Name: DB_PASSWORD
              Value: !Ref DbPassword
            - Name: DB_PORT
              Value: !GetAtt Db.Endpoint.Port
            - Name: DB_USERNAME
              Value: !Ref DbUsername
            - Name: NODE_ENV
              Value: production
          Command:
            - db
            - migrate

  Cluster:
    Type: AWS::ECS::Cluster

  # Create a rule on the load balancer for routing traffic to the target group
  LoadBalancerRule:
    Type: AWS::ElasticLoadBalancingV2::ListenerRule
    Properties:
      Actions:
        - TargetGroupArn: !Ref ServerTargetGroup
          Type: 'forward'
      Conditions:
        - Field: path-pattern
          Values:
            - '*'
      ListenerArn: !Ref PublicLoadBalancerHttpsListener
      Priority: 1

  # A target group. This is used for keeping track of all the tasks, and
  # what IP addresses / port numbers they have. You can query it yourself,
  # to use the addresses yourself, but most often this target group is just
  # connected to an application load balancer, or network load balancer, so
  # it can automatically distribute traffic across all the targets.
  ServerTargetGroup:
    Type: AWS::ElasticLoadBalancingV2::TargetGroup
    Properties:
      Name: api
      HealthCheckIntervalSeconds: 20
      HealthCheckPort: !Ref ApiPort
      HealthCheckPath: /health
      HealthCheckProtocol: HTTP
      HealthCheckTimeoutSeconds: 10
      HealthyThresholdCount: 2
      TargetType: ip
      Port: !Ref ApiPort
      Protocol: HTTP
      UnhealthyThresholdCount: 2
      VpcId: !Ref VPC

  # The service. The service is a resource which allows you to run multiple
  # copies of a type of task, and gather up their logs and metrics, as well
  # as monitor the number of running tasks and replace any that have crashed
  ApiService:
    Type: AWS::ECS::Service
    DependsOn: LoadBalancerRule
    Properties:
      ServiceName: api
      Cluster: !Ref Cluster
      LaunchType: FARGATE
      DeploymentConfiguration:
        MaximumPercent: 200
        MinimumHealthyPercent: 100
      NetworkConfiguration:
        AwsvpcConfiguration:
          AssignPublicIp: ENABLED
          SecurityGroups:
            - !Ref FargateContainerSecurityGroup
          Subnets:
            - !Ref PublicSubnet1
            - !Ref PublicSubnet2
      TaskDefinition: !Ref ApiTaskDefinition
      LoadBalancers:
        - ContainerName: api
          ContainerPort: !Ref ApiPort
          TargetGroupArn: !Ref ServerTargetGroup

  # The task definition. This is a simple metadata description of what
  # container to run, and what resource requirements it has.
  WorkerTaskDefinition:
    Type: AWS::ECS::TaskDefinition
    DeletionPolicy: Delete
    Properties:
      Cpu: !Ref WorkerCpu
      Memory: !Ref WorkerMemory
      NetworkMode: awsvpc
      RequiresCompatibilities:
        - FARGATE
      ExecutionRoleArn: !Ref 'ECSTaskExecutionRole'
      ContainerDefinitions:
        - Name: worker
          Cpu: !Ref WorkerCpu
          Memory: !Ref WorkerMemory
          LogConfiguration:
            LogDriver: awslogs
            Options:
              awslogs-create-group: true
              awslogs-region: !Ref AWS::Region
              awslogs-group: !Sub /aws/ecs/${AWS::StackName}-worker
              awslogs-stream-prefix: !Ref AWS::StackName
          PortMappings:
            - ContainerPort: !Ref WorkerPort
          Image:
            !Join [
              '',
              [!Ref 'AWS::AccountId', '.dkr.ecr.', !Ref 'AWS::Region', '.amazonaws.com/', !Ref 'ApiImageRepository'],
            ]
          Environment:
            - Name: APP_GRAPHQL_PORT
              Value: !Ref ApiPort
            - Name: LOG_LEVEL
              Value: debug
            - Name: APP_SESSION_SECRET
              Value: !Ref ApiSessionSecret
            - Name: APP_WEB_URI
              Value: !Sub https://${DomainName}
            - Name: CDN_DOMAIN_NAME
              Value: !GetAtt WebDistribution.DomainName
            - Name: DB_HOST
              Value: !GetAtt Db.Endpoint.Address
            - Name: DB_NAME
              Value: !Ref DbName
            - Name: DB_PASSWORD
              Value: !Ref DbPassword
            - Name: DB_PORT
              Value: !GetAtt Db.Endpoint.Port
            - Name: DB_USERNAME
              Value: !Ref DbUsername
            - Name: NODE_ENV
              Value: production
            - Name: REDIS_HOST
              Value: !GetAtt ElasticacheCluster.RedisEndpoint.Address
            - Name: REDIS_PORT
              Value: !GetAtt ElasticacheCluster.RedisEndpoint.Port
            - Name: S3_BUCKET
              Value: !Ref MediaBucket
            - Name: S3_VIDEO_SRC_BUCKET
              Value: !Ref Source
            - Name: SQS_VIDEO_QUEUE_URL
              Value: !Ref SqsQueue
          Command:
            - jobs

  # The service. The service is a resource which allows you to run multiple
  # copies of a type of task, and gather up their logs and metrics, as well
  # as monitor the number of running tasks and replace any that have crashed
  WorkerService:
    Type: AWS::ECS::Service
    Properties:
      ServiceName: worker
      Cluster: !Ref Cluster
      LaunchType: FARGATE
      DeploymentConfiguration:
        MaximumPercent: 200
        MinimumHealthyPercent: 100
      NetworkConfiguration:
        AwsvpcConfiguration:
          AssignPublicIp: ENABLED
          SecurityGroups:
            - !Ref FargateContainerSecurityGroup
          Subnets:
            - !Ref PublicSubnet1
            - !Ref PublicSubnet2
      TaskDefinition: !Ref WorkerTaskDefinition

  # Video Stack
  # https://github.com/awslabs/video-on-demand-on-aws
  CustomResourceRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - lambda.amazonaws.com
            Action:
              - sts:AssumeRole
      Path: '/'
      Policies:
        - PolicyName: !Sub '${AWS::StackName}-custom-resource'
          PolicyDocument:
            Statement:
              - Effect: Allow
                Action:
                  - logs:CreateLogGroup
                  - logs:CreateLogStream
                  - logs:PutLogEvents
                Resource:
                  - !Sub 'arn:${AWS::Partition}:logs:${AWS::Region}:${AWS::AccountId}:log-group:/aws/lambda/*'
              - Effect: Allow
                Action:
                  - s3:PutBucketNotification
                  - s3:PutObject
                  - s3:PutObjectAcl
                Resource:
                  - !GetAtt Source.Arn
              - Effect: Allow
                Action:
                  - mediaconvert:CreatePreset
                  - mediaconvert:CreateJobTemplate
                  - mediaconvert:DeletePreset
                  - mediaconvert:DeleteJobTemplate
                  - mediaconvert:DescribeEndpoints
                  - mediaconvert:ListJobTemplates
                Resource:
                  - !Sub 'arn:${AWS::Partition}:mediaconvert:${AWS::Region}:${AWS::AccountId}:*'
              - Effect: Allow
                Action:
                  - mediapackage-vod:DeleteAsset
                  - mediapackage-vod:DeletePackagingConfiguration
                Resource:
                  - !Sub 'arn:${AWS::Partition}:mediapackage-vod:${AWS::Region}:${AWS::AccountId}:assets/*'
                  - !Sub 'arn:${AWS::Partition}:mediapackage-vod:${AWS::Region}:${AWS::AccountId}:packaging-configurations/packaging-config-*'
              - Effect: Allow
                Action:
                  - mediapackage-vod:DescribePackagingGroup
                  - mediapackage-vod:DeletePackagingGroup
                Resource:
                  - !Sub 'arn:${AWS::Partition}:mediapackage-vod:${AWS::Region}:${AWS::AccountId}:packaging-groups/${AWS::StackName}-packaging-group'
              - Effect: Allow
                Action:
                  - mediapackage-vod:CreatePackagingConfiguration
                  - mediapackage-vod:CreatePackagingGroup
                  - mediapackage-vod:ListAssets
                  - mediapackage-vod:ListPackagingConfigurations
                  - mediapackage-vod:ListPackagingGroups
                Resource: '*'
              - Effect: Allow
                Action:
                  - cloudfront:GetDistributionConfig
                  - cloudfront:UpdateDistribution
                Resource:
                  - !Sub 'arn:${AWS::Partition}:cloudfront::${AWS::AccountId}:distribution/${CloudFront}'
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W11
            reason: '* is required to create CloudWatch logs and interact with MediaConvert / MediaPackage actions that do not support resource level permissions'

  StepFunctionsServiceRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - !Sub 'states.${AWS::Region}.amazonaws.com'
            Action:
              - sts:AssumeRole
      Policies:
        - PolicyName: !Sub '${AWS::StackName}-stepfunctions-service-role'
          PolicyDocument:
            Statement:
              - Effect: Allow
                Action:
                  - lambda:InvokeFunction
                Resource:
                  - !Sub 'arn:${AWS::Partition}:lambda:${AWS::Region}:${AWS::AccountId}:function:*'
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W11
            reason: 'The * resource is required since the functions need to be created before the state machine'

  MediaConvertRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - mediaconvert.amazonaws.com
            Action:
              - sts:AssumeRole
      Policies:
        - PolicyName: !Sub '${AWS::StackName}-mediatranscode-policy'
          PolicyDocument:
            Statement:
              - Effect: Allow
                Action:
                  - s3:GetObject
                  - s3:PutObject
                Resource:
                  - !Sub '${Source.Arn}/*'
                  - !Sub '${Destination.Arn}/*'
              - Effect: Allow
                Action:
                  - execute-api:Invoke
                Resource:
                  - !Sub 'arn:${AWS::Partition}:execute-api:${AWS::Region}:${AWS::AccountId}:*'
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W11
            reason: '/* required to get/put objects to S3'

  MediaPackageVodRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - mediapackage.amazonaws.com
            Action:
              - sts:AssumeRole
      Policies:
        - PolicyName: !Sub '${AWS::StackName}-mediapackagevod-policy'
          PolicyDocument:
            Statement:
              - Effect: Allow
                Action:
                  - s3:GetObject
                  - s3:GetBucketLocation
                  - s3:GetBucketRequestPayment
                Resource:
                  - !Sub '${Destination.Arn}'
                  - !Sub '${Destination.Arn}/*'
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W11
            reason: '* is required to get objects from S3'

  S3LambdaInvokeVideo:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !GetAtt StepFunctions.Arn
      Action: lambda:InvokeFunction
      Principal: s3.amazonaws.com
      SourceAccount: !Ref AWS::AccountId

  CloudWatchLambdaInvokeErrors:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !GetAtt ErrorHandler.Arn
      Action: lambda:InvokeFunction
      Principal: events.amazonaws.com
      SourceArn: !GetAtt EncodeErrorRule.Arn

  CloudWatchLambdaInvokeCompletes:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !GetAtt StepFunctions.Arn
      Action: lambda:InvokeFunction
      Principal: events.amazonaws.com
      SourceArn: !GetAtt EncodeCompleteRule.Arn

  DestBucketPolicy:
    Type: AWS::S3::BucketPolicy
    Properties:
      Bucket: !Ref Destination
      PolicyDocument:
        Statement:
          - Effect: Allow
            Action:
              - s3:GetObject
            Resource: !Sub 'arn:${AWS::Partition}:s3:::${Destination}/*'
            Principal:
              CanonicalUser: !GetAtt DestinationOriginAccessIdentity.S3CanonicalUserId

  EncodeCompleteRule:
    Type: AWS::Events::Rule
    Properties:
      Name: !Sub '${AWS::StackName}-EncodeComplete'
      Description: MediaConvert Completed event rule
      EventPattern:
        source:
          - aws.mediaconvert
        detail:
          status:
            - COMPLETE
          userMetadata:
            workflow:
              - !Ref AWS::StackName
      Targets:
        - Arn: !GetAtt StepFunctions.Arn
          Id: !Sub '${AWS::StackName}-StepFunctions'

  EncodeErrorRule:
    Type: AWS::Events::Rule
    Properties:
      Name: !Sub '${AWS::StackName}-EncodeError'
      Description: MediaConvert Error event rule
      EventPattern:
        source:
          - aws.mediaconvert
        detail:
          status:
            - ERROR
          userMetadata:
            workflow:
              - !Ref AWS::StackName
      Targets:
        - Arn: !GetAtt ErrorHandler.Arn
          Id: !Sub '${AWS::StackName}-EncodeError'

  DynamoDBTable:
    Type: AWS::DynamoDB::Table
    Properties:
      BillingMode: PAY_PER_REQUEST
      AttributeDefinitions:
        - AttributeName: guid
          AttributeType: S
        - AttributeName: srcBucket
          AttributeType: S
        - AttributeName: startTime
          AttributeType: S
      KeySchema:
        - AttributeName: guid
          KeyType: HASH
      GlobalSecondaryIndexes:
        - IndexName: srcBucket-startTime-index
          KeySchema:
            - AttributeName: srcBucket
              KeyType: HASH
            - AttributeName: startTime
              KeyType: RANGE
          Projection:
            ProjectionType: ALL
      TableName: !Ref AWS::StackName
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W28
            reason: 'Table name is set to the stack name'
          - id: W74
            reason: ' The DynamoDB table is configured to use the default encryption'

  Source:
    DeletionPolicy: Retain
    UpdateReplacePolicy: Retain
    Type: AWS::S3::Bucket
    Properties:
      LoggingConfiguration:
        DestinationBucketName: !Ref Logs
        LogFilePrefix: s3-access/
      LifecycleConfiguration:
        Rules:
          - Id: !Sub '${AWS::StackName}-source-archive'
            TagFilters:
              - Key: !Ref AWS::StackName
                Value: GLACIER
            Status: Enabled
            Transitions:
              - TransitionInDays: 1
                StorageClass: GLACIER
          - Id: !Sub '${AWS::StackName}-source-deep-archive'
            TagFilters:
              - Key: !Ref AWS::StackName
                Value: DEEP_ARCHIVE
            Status: Enabled
            Transitions:
              - TransitionInDays: 1
                StorageClass: DEEP_ARCHIVE
      BucketEncryption:
        ServerSideEncryptionConfiguration:
          - ServerSideEncryptionByDefault:
              SSEAlgorithm: AES256
      PublicAccessBlockConfiguration:
        BlockPublicAcls: true
        BlockPublicPolicy: true
        IgnorePublicAcls: true
        RestrictPublicBuckets: true
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W51
            reason: 'Bucket does not need a bucket policy'

  Destination:
    DeletionPolicy: Retain
    UpdateReplacePolicy: Retain
    Type: AWS::S3::Bucket
    Properties:
      LoggingConfiguration:
        DestinationBucketName: !Ref Logs
        LogFilePrefix: s3-access/
      CorsConfiguration:
        CorsRules:
          - AllowedMethods: [GET]
            AllowedOrigins: ['*']
            AllowedHeaders: ['*']
            MaxAge: 3000
      PublicAccessBlockConfiguration:
        BlockPublicAcls: true
        BlockPublicPolicy: true
        IgnorePublicAcls: true
        RestrictPublicBuckets: true
      BucketEncryption:
        ServerSideEncryptionConfiguration:
          - ServerSideEncryptionByDefault:
              SSEAlgorithm: AES256

  Logs:
    DeletionPolicy: Retain
    UpdateReplacePolicy: Retain
    Type: AWS::S3::Bucket
    Properties:
      AccessControl: LogDeliveryWrite
      BucketEncryption:
        ServerSideEncryptionConfiguration:
          - ServerSideEncryptionByDefault:
              SSEAlgorithm: AES256
      PublicAccessBlockConfiguration:
        BlockPublicAcls: true
        BlockPublicPolicy: true
        IgnorePublicAcls: true
        RestrictPublicBuckets: true
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W35
            reason: 'Used to store access logs for other buckets'
          - id: W51
            reason: 'Bucket does not need a bucket policy'

  SnsTopic:
    Type: AWS::SNS::Topic
    Properties:
      DisplayName: !Sub '${AWS::StackName}-Notifications'
      KmsMasterKeyId: alias/aws/sns
      Subscription:
        - Endpoint: !Ref AdminEmail
          Protocol: email

  SqsQueue:
    Type: AWS::SQS::Queue
    Properties:
      VisibilityTimeout: 120
      QueueName: !Sub ${AWS::StackName}
      RedrivePolicy:
        deadLetterTargetArn: !Sub ${SqsQueueDlq.Arn}
        maxReceiveCount: 1
      KmsDataKeyReusePeriodSeconds: 300
      KmsMasterKeyId: alias/aws/sqs

  SqsQueueDlq:
    Type: AWS::SQS::Queue
    Properties:
      VisibilityTimeout: 120
      QueueName: !Sub ${AWS::StackName}-dlq
      KmsDataKeyReusePeriodSeconds: 300
      KmsMasterKeyId: alias/aws/sqs

  DestinationOriginAccessIdentity:
    Type: AWS::CloudFront::CloudFrontOriginAccessIdentity
    Properties:
      CloudFrontOriginAccessIdentityConfig:
        Comment: !Sub 'access-identity-${Destination}'

  CloudFront:
    Type: AWS::CloudFront::Distribution
    Properties:
      DistributionConfig:
        Origins:
          - DomainName: !Sub '${Destination}.s3.${AWS::Region}.amazonaws.com'
            Id: vodS3Origin
            S3OriginConfig:
              OriginAccessIdentity: !Sub 'origin-access-identity/cloudfront/${DestinationOriginAccessIdentity}'
        Enabled: true
        Logging:
          IncludeCookies: false
          Bucket: !GetAtt Logs.DomainName
          Prefix: cloudfront-logs/
        DefaultCacheBehavior:
          AllowedMethods:
            - GET
            - HEAD
            - OPTIONS
          TargetOriginId: vodS3Origin
          ForwardedValues:
            QueryString: false
            Cookies:
              Forward: none
            Headers:
              - Origin
              - Access-Control-Request-Method
              - Access-Control-Request-Headers
          ViewerProtocolPolicy: allow-all
        PriceClass: PriceClass_100
        ViewerCertificate:
          CloudFrontDefaultCertificate: true
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W70
            reason: 'CloudFront automatically sets the security policy to TLSv1 when the distribution uses the CloudFront domain name (CloudFrontDefaultCertificate=true)'

  S3Config:
    DependsOn: CloudFront
    Type: Custom::S3
    Properties:
      ServiceToken: !GetAtt CustomResource.Arn
      Source: !Ref Source
      IngestArn: !GetAtt StepFunctions.Arn
      Resource: S3Notification
      WorkflowTrigger: !Ref WorkflowTrigger

  MediaConvertEndPoint:
    Type: Custom::LoadLambda
    Properties:
      ServiceToken: !GetAtt CustomResource.Arn
      Resource: EndPoint

  MediaConvertTemplates:
    Type: Custom::LoadLambda
    Properties:
      ServiceToken: !GetAtt CustomResource.Arn
      Resource: MediaConvertTemplates
      StackName: !Ref AWS::StackName
      EndPoint: !GetAtt MediaConvertEndPoint.EndpointUrl
      EnableMediaPackage: !Ref EnableMediaPackage

  MediaPackageVod:
    Type: Custom::LoadLambda
    Properties:
      ServiceToken: !GetAtt CustomResource.Arn
      Resource: MediaPackageVod
      StackName: !Ref AWS::StackName
      GroupId: !Sub '${AWS::StackName}-packaging-group'
      PackagingConfigurations: 'HLS,DASH,MSS,CMAF'
      DistributionId: !Ref CloudFront
      EnableMediaPackage: !Ref EnableMediaPackage

  CustomResource:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub '${AWS::StackName}-custom-resource'
      Description: Used to deploy resources not supported by CloudFormation
      Handler: index.handler
      Role: !GetAtt CustomResourceRole.Arn
      Code:
        S3Bucket: !Join ['-', [!FindInMap ['SourceCode', 'General', 'S3Bucket'], Ref: 'AWS::Region']]
        S3Key: !Join ['/', [!FindInMap ['SourceCode', 'General', 'KeyPrefix'], 'custom-resource.zip']]
      Runtime: nodejs12.x
      Timeout: 180
      Environment:
        Variables:
          AWS_NODEJS_CONNECTION_REUSE_ENABLED: '1'

  StepFunctionsRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - lambda.amazonaws.com
            Action:
              - sts:AssumeRole
      Policies:
        - PolicyName: !Sub '${AWS::StackName}-step-functions-role'
          PolicyDocument:
            Statement:
              - Effect: Allow
                Action:
                  - states:StartExecution
                Resource:
                  - !Sub 'arn:${AWS::Partition}:states:${AWS::Region}:${AWS::AccountId}:stateMachine:${AWS::StackName}-ingest'
                  - !Sub 'arn:${AWS::Partition}:states:${AWS::Region}:${AWS::AccountId}:stateMachine:${AWS::StackName}-process'
                  - !Sub 'arn:${AWS::Partition}:states:${AWS::Region}:${AWS::AccountId}:stateMachine:${AWS::StackName}-publish'
              - Effect: Allow
                Action:
                  - lambda:InvokeFunction
                Resource:
                  - !Sub 'arn:${AWS::Partition}:lambda:${AWS::Region}:${AWS::AccountId}:function:${AWS::StackName}-error-handler'
              - Effect: Allow
                Action:
                  - logs:CreateLogGroup
                  - logs:CreateLogStream
                  - logs:PutLogEvents
                Resource:
                  - !Sub 'arn:${AWS::Partition}:logs:${AWS::Region}:${AWS::AccountId}:log-group:/aws/lambda/*'
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W11
            reason: '* is used so that the Lambda function can create log groups'

  StepFunctions:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub '${AWS::StackName}-step-functions'
      Description: Creates a unique identifer (GUID) and executes the Ingest StateMachine
      Handler: index.handler
      Role: !GetAtt StepFunctionsRole.Arn
      Code:
        S3Bucket: !Join ['-', [!FindInMap ['SourceCode', 'General', 'S3Bucket'], Ref: 'AWS::Region']]
        S3Key: !Join ['/', [!FindInMap ['SourceCode', 'General', 'KeyPrefix'], 'step-functions.zip']]
      Runtime: nodejs12.x
      Timeout: 120
      Environment:
        Variables:
          AWS_NODEJS_CONNECTION_REUSE_ENABLED: '1'
          IngestWorkflow: !Sub 'arn:${AWS::Partition}:states:${AWS::Region}:${AWS::AccountId}:stateMachine:${AWS::StackName}-ingest'
          ProcessWorkflow: !Sub 'arn:${AWS::Partition}:states:${AWS::Region}:${AWS::AccountId}:stateMachine:${AWS::StackName}-process'
          PublishWorkflow: !Sub 'arn:${AWS::Partition}:states:${AWS::Region}:${AWS::AccountId}:stateMachine:${AWS::StackName}-publish'
          ErrorHandler: !GetAtt ErrorHandler.Arn

  InputValidateRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - lambda.amazonaws.com
            Action:
              - sts:AssumeRole
      Policies:
        - PolicyName: !Sub '${AWS::StackName}-input-validate-role'
          PolicyDocument:
            Statement:
              - Effect: Allow
                Action:
                  - s3:GetObject
                Resource:
                  - !Sub '${Source.Arn}/*'
              - Effect: Allow
                Action:
                  - lambda:InvokeFunction
                Resource:
                  - !Sub 'arn:${AWS::Partition}:lambda:${AWS::Region}:${AWS::AccountId}:function:${AWS::StackName}-error-handler'
              - Effect: Allow
                Action:
                  - logs:CreateLogGroup
                  - logs:CreateLogStream
                  - logs:PutLogEvents
                Resource:
                  - !Sub 'arn:${AWS::Partition}:logs:${AWS::Region}:${AWS::AccountId}:log-group:/aws/lambda/*'
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W11
            reason: '* is used so that the Lambda function can create log groups; S3 action is limited to one bucket'

  InputValidate:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub '${AWS::StackName}-input-validate'
      Description: Validates the input given to the workflow
      Handler: index.handler
      Role: !GetAtt InputValidateRole.Arn
      Code:
        S3Bucket: !Join ['-', [!FindInMap ['SourceCode', 'General', 'S3Bucket'], Ref: 'AWS::Region']]
        S3Key: !Join ['/', [!FindInMap ['SourceCode', 'General', 'KeyPrefix'], 'input-validate.zip']]
      Runtime: nodejs12.x
      Timeout: 120
      Environment:
        Variables:
          AWS_NODEJS_CONNECTION_REUSE_ENABLED: '1'
          ErrorHandler: !GetAtt ErrorHandler.Arn
          WorkflowName: !Ref AWS::StackName
          Source: !Ref Source
          Destination: !Ref Destination
          FrameCapture: !Ref FrameCapture
          ArchiveSource: !Ref Glacier
          MediaConvert_Template_2160p: !If
            - IsMediaPackageEnabled
            - !Sub '${AWS::StackName}_Ott_2160p_Avc_Aac_16x9_mvod'
            - !Sub '${AWS::StackName}_Ott_2160p_Avc_Aac_16x9_qvbr'
          MediaConvert_Template_1080p: !If
            - IsMediaPackageEnabled
            - !Sub '${AWS::StackName}_Ott_1080p_Avc_Aac_16x9_mvod'
            - !Sub '${AWS::StackName}_Ott_1080p_Avc_Aac_16x9_qvbr'
          MediaConvert_Template_720p: !If
            - IsMediaPackageEnabled
            - !Sub '${AWS::StackName}_Ott_720p_Avc_Aac_16x9_mvod'
            - !Sub '${AWS::StackName}_Ott_720p_Avc_Aac_16x9_qvbr'
          CloudFront: !GetAtt CloudFront.DomainName
          EnableMediaPackage: !Ref EnableMediaPackage
          InputRotate: DEGREE_0
          EnableSns: !Ref EnableSns
          EnableSqs: !Ref EnableSqs
          AcceleratedTranscoding: !Ref AcceleratedTranscoding

  MediainfoRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - lambda.amazonaws.com
            Action:
              - sts:AssumeRole
      Policies:
        - PolicyName: !Sub '${AWS::StackName}-mediainfo-role'
          PolicyDocument:
            Statement:
              - Effect: Allow
                Action:
                  - s3:GetObject
                Resource:
                  - !Sub '${Source.Arn}/*'
              - Effect: Allow
                Action:
                  - lambda:InvokeFunction
                Resource:
                  - !Sub 'arn:${AWS::Partition}:lambda:${AWS::Region}:${AWS::AccountId}:function:${AWS::StackName}-error-handler'
              - Effect: Allow
                Action:
                  - logs:CreateLogGroup
                  - logs:CreateLogStream
                  - logs:PutLogEvents
                Resource:
                  - !Sub 'arn:${AWS::Partition}:logs:${AWS::Region}:${AWS::AccountId}:log-group:/aws/lambda/*'
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W11
            reason: '* is limited to one S3 bucket'

  Mediainfo:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub '${AWS::StackName}-mediainfo'
      Description: Runs mediainfo on a pre-signed S3 URL
      Handler: lambda_function.lambda_handler
      Role: !GetAtt MediainfoRole.Arn
      Code:
        S3Bucket: !Join ['-', [!FindInMap ['SourceCode', 'General', 'S3Bucket'], Ref: 'AWS::Region']]
        S3Key: !Join ['/', [!FindInMap ['SourceCode', 'General', 'KeyPrefix'], 'mediainfo.zip']]
      Runtime: python3.7
      Timeout: 120
      Environment:
        Variables:
          ErrorHandler: !GetAtt ErrorHandler.Arn

  DynamoUpdateRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - lambda.amazonaws.com
            Action:
              - sts:AssumeRole
      Policies:
        - PolicyName: !Sub '${AWS::StackName}-dynamo-role'
          PolicyDocument:
            Statement:
              - Effect: Allow
                Action:
                  - lambda:InvokeFunction
                Resource:
                  - !Sub 'arn:${AWS::Partition}:lambda:${AWS::Region}:${AWS::AccountId}:function:${AWS::StackName}-error-handler'
              - Effect: Allow
                Action:
                  - dynamodb:UpdateItem
                Resource:
                  - !Sub 'arn:${AWS::Partition}:dynamodb:${AWS::Region}:${AWS::AccountId}:table/${DynamoDBTable}'
              - Effect: Allow
                Action:
                  - logs:CreateLogGroup
                  - logs:CreateLogStream
                  - logs:PutLogEvents
                Resource:
                  - !Sub 'arn:${AWS::Partition}:logs:${AWS::Region}:${AWS::AccountId}:log-group:/aws/lambda/*'
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W11
            reason: '* is used so that the Lambda function can create log groups'

  DynamodbUpdate:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub '${AWS::StackName}-dynamo'
      Description: Updates DynamoDB with event data
      Handler: index.handler
      Role: !GetAtt DynamoUpdateRole.Arn
      Code:
        S3Bucket: !Join ['-', [!FindInMap ['SourceCode', 'General', 'S3Bucket'], Ref: 'AWS::Region']]
        S3Key: !Join ['/', [!FindInMap ['SourceCode', 'General', 'KeyPrefix'], 'dynamo.zip']]
      Runtime: nodejs12.x
      Timeout: 120
      Environment:
        Variables:
          AWS_NODEJS_CONNECTION_REUSE_ENABLED: '1'
          DynamoDBTable: !Ref DynamoDBTable
          ErrorHandler: !GetAtt ErrorHandler.Arn

  ProfilerRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - lambda.amazonaws.com
            Action:
              - sts:AssumeRole
      Policies:
        - PolicyName: !Sub '${AWS::StackName}-profiler-role'
          PolicyDocument:
            Statement:
              - Effect: Allow
                Action:
                  - lambda:InvokeFunction
                Resource:
                  - !Sub 'arn:${AWS::Partition}:lambda:${AWS::Region}:${AWS::AccountId}:function:${AWS::StackName}-error-handler'
              - Effect: Allow
                Action:
                  - dynamodb:GetItem
                Resource:
                  - !Sub 'arn:${AWS::Partition}:dynamodb:${AWS::Region}:${AWS::AccountId}:table/${DynamoDBTable}'
              - Effect: Allow
                Action:
                  - logs:CreateLogGroup
                  - logs:CreateLogStream
                  - logs:PutLogEvents
                Resource:
                  - !Sub 'arn:${AWS::Partition}:logs:${AWS::Region}:${AWS::AccountId}:log-group:/aws/lambda/*'
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W11
            reason: '* is used so that the Lambda function can create log groups'

  Profiler:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub '${AWS::StackName}-profiler'
      Description: Sets an EncodeProfile based on mediainfo output
      Handler: index.handler
      Role: !GetAtt ProfilerRole.Arn
      Code:
        S3Bucket: !Join ['-', [!FindInMap ['SourceCode', 'General', 'S3Bucket'], Ref: 'AWS::Region']]
        S3Key: !Join ['/', [!FindInMap ['SourceCode', 'General', 'KeyPrefix'], 'profiler.zip']]
      Runtime: nodejs12.x
      Timeout: 120
      Environment:
        Variables:
          AWS_NODEJS_CONNECTION_REUSE_ENABLED: '1'
          DynamoDBTable: !Ref DynamoDBTable
          ErrorHandler: !GetAtt ErrorHandler.Arn

  EncodeRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - lambda.amazonaws.com
            Action:
              - sts:AssumeRole
      Policies:
        - PolicyName: !Sub '${AWS::StackName}-encode-role'
          PolicyDocument:
            Statement:
              - Effect: Allow
                Action:
                  - lambda:InvokeFunction
                Resource:
                  - !Sub 'arn:${AWS::Partition}:lambda:${AWS::Region}:${AWS::AccountId}:function:${AWS::StackName}-error-handler'
              - Effect: Allow
                Action:
                  - mediaconvert:CreateJob
                  - mediaconvert:GetJobTemplate
                Resource:
                  - !Sub 'arn:${AWS::Partition}:mediaconvert:${AWS::Region}:${AWS::AccountId}:*'
              - Effect: Allow
                Action:
                  - iam:PassRole
                Resource:
                  - !GetAtt MediaConvertRole.Arn
              - Effect: Allow
                Action:
                  - logs:CreateLogGroup
                  - logs:CreateLogStream
                  - logs:PutLogEvents
                Resource:
                  - !Sub 'arn:${AWS::Partition}:logs:${AWS::Region}:${AWS::AccountId}:log-group:/aws/lambda/*'
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W11
            reason: '* is used so that the Lambda function can create log groups; MediaConvert job ids are randomly generated'

  Encode:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub '${AWS::StackName}-encode'
      Description: Creates a MediaConvert encode job
      Handler: index.handler
      Role: !GetAtt EncodeRole.Arn
      Code:
        S3Bucket: !Join ['-', [!FindInMap ['SourceCode', 'General', 'S3Bucket'], Ref: 'AWS::Region']]
        S3Key: !Join ['/', [!FindInMap ['SourceCode', 'General', 'KeyPrefix'], 'encode.zip']]
      Runtime: nodejs12.x
      Timeout: 120
      Environment:
        Variables:
          AWS_NODEJS_CONNECTION_REUSE_ENABLED: '1'
          ErrorHandler: !GetAtt ErrorHandler.Arn
          MediaConvertRole: !GetAtt MediaConvertRole.Arn
          EndPoint: !GetAtt MediaConvertEndPoint.EndpointUrl

  OutputValidateRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - lambda.amazonaws.com
            Action:
              - sts:AssumeRole
      Policies:
        - PolicyName: !Sub '${AWS::StackName}-output-validate-role'
          PolicyDocument:
            Statement:
              - Effect: Allow
                Action:
                  - lambda:InvokeFunction
                Resource:
                  - !Sub 'arn:${AWS::Partition}:lambda:${AWS::Region}:${AWS::AccountId}:function:${AWS::StackName}-error-handler'
              - Effect: Allow
                Action:
                  - dynamodb:GetItem
                Resource:
                  - !Sub 'arn:${AWS::Partition}:dynamodb:${AWS::Region}:${AWS::AccountId}:table/${DynamoDBTable}'
              - Effect: Allow
                Action:
                  - s3:ListBucket
                Resource:
                  - !GetAtt Destination.Arn
              - Effect: Allow
                Action:
                  - logs:CreateLogGroup
                  - logs:CreateLogStream
                  - logs:PutLogEvents
                Resource:
                  - !Sub 'arn:${AWS::Partition}:logs:${AWS::Region}:${AWS::AccountId}:log-group:/aws/lambda/*'
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W11
            reason: '* is used so that the Lambda function can create log groups'

  OutputValidate:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub '${AWS::StackName}-output-validate'
      Description: Parses MediaConvert job output
      Handler: index.handler
      Role: !GetAtt OutputValidateRole.Arn
      Code:
        S3Bucket: !Join ['-', [!FindInMap ['SourceCode', 'General', 'S3Bucket'], Ref: 'AWS::Region']]
        S3Key: !Join ['/', [!FindInMap ['SourceCode', 'General', 'KeyPrefix'], 'output-validate.zip']]
      Runtime: nodejs12.x
      Timeout: 120
      Environment:
        Variables:
          AWS_NODEJS_CONNECTION_REUSE_ENABLED: '1'
          DynamoDBTable: !Ref DynamoDBTable
          ErrorHandler: !GetAtt ErrorHandler.Arn
          EndPoint: !GetAtt MediaConvertEndPoint.EndpointUrl

  ArchiveSourceRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - lambda.amazonaws.com
            Action:
              - sts:AssumeRole
      Policies:
        - PolicyName: !Sub '${AWS::StackName}-archive-source-role'
          PolicyDocument:
            Statement:
              - Effect: Allow
                Action:
                  - s3:PutObjectTagging
                Resource:
                  - !Sub '${Source.Arn}/*'
              - Effect: Allow
                Action:
                  - lambda:InvokeFunction
                Resource:
                  - !Sub 'arn:${AWS::Partition}:lambda:${AWS::Region}:${AWS::AccountId}:function:${AWS::StackName}-error-handler'
              - Effect: Allow
                Action:
                  - logs:CreateLogGroup
                  - logs:CreateLogStream
                  - logs:PutLogEvents
                Resource:
                  - !Sub 'arn:${AWS::Partition}:logs:${AWS::Region}:${AWS::AccountId}:log-group:/aws/lambda/*'
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W11
            reason: '* is used so that the Lambda function can create log groups; S3 action is limited to one bucket'

  ArchiveSource:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub '${AWS::StackName}-archive-source'
      Description: Updates tags on source files to enable Glacier
      Handler: index.handler
      Role: !GetAtt ArchiveSourceRole.Arn
      Code:
        S3Bucket: !Join ['-', [!FindInMap ['SourceCode', 'General', 'S3Bucket'], Ref: 'AWS::Region']]
        S3Key: !Join ['/', [!FindInMap ['SourceCode', 'General', 'KeyPrefix'], 'archive-source.zip']]
      Runtime: nodejs12.x
      Timeout: 120
      Environment:
        Variables:
          AWS_NODEJS_CONNECTION_REUSE_ENABLED: '1'
          ErrorHandler: !GetAtt ErrorHandler.Arn

  SqsSendMessageRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - lambda.amazonaws.com
            Action:
              - sts:AssumeRole
      Policies:
        - PolicyName: !Sub '${AWS::StackName}-sqs-publish-role'
          PolicyDocument:
            Statement:
              - Effect: Allow
                Action:
                  - lambda:InvokeFunction
                Resource:
                  - !Sub 'arn:aws:lambda:${AWS::Region}:${AWS::AccountId}:function:${AWS::StackName}-error-handler'
              - Effect: Allow
                Action:
                  - sqs:SendMessage
                Resource:
                  - !GetAtt SqsQueue.Arn
              - Effect: Allow
                Action:
                  - logs:CreateLogGroup
                  - logs:CreateLogStream
                  - logs:PutLogEvents
                Resource:
                  - !Sub 'arn:aws:logs:${AWS::Region}:${AWS::AccountId}:log-group:/aws/lambda/*'
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W11
            reason: '* is used so that the Lambda function can create log groups'

  SqsSendMessage:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub ${AWS::StackName}-sqs-publish
      Description: Publish the workflow results to an SQS queue
      Handler: index.handler
      Role: !GetAtt SqsSendMessageRole.Arn
      Code:
        S3Bucket: !Join ['-', [!FindInMap ['SourceCode', 'General', 'S3Bucket'], Ref: 'AWS::Region']]
        S3Key: !Join ['/', [!FindInMap ['SourceCode', 'General', 'KeyPrefix'], 'sqs-publish.zip']]
      Runtime: nodejs12.x
      Timeout: 120
      Environment:
        Variables:
          AWS_NODEJS_CONNECTION_REUSE_ENABLED: '1'
          ErrorHandler: !GetAtt ErrorHandler.Arn
          SqsQueue: !Ref SqsQueue
  SnsNotificationRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - lambda.amazonaws.com
            Action:
              - sts:AssumeRole
      Policies:
        - PolicyName: !Sub '${AWS::StackName}-sns-notification-role'
          PolicyDocument:
            Statement:
              - Effect: Allow
                Action:
                  - lambda:InvokeFunction
                Resource:
                  - !Sub 'arn:${AWS::Partition}:lambda:${AWS::Region}:${AWS::AccountId}:function:${AWS::StackName}-error-handler'
              - Effect: Allow
                Action:
                  - sns:Publish
                Resource:
                  - !Ref SnsTopic
              - Effect: Allow
                Action:
                  - logs:CreateLogGroup
                  - logs:CreateLogStream
                  - logs:PutLogEvents
                Resource:
                  - !Sub 'arn:${AWS::Partition}:logs:${AWS::Region}:${AWS::AccountId}:log-group:/aws/lambda/*'
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W11
            reason: '* is used so that the Lambda function can create log groups'

  SnsNotification:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub '${AWS::StackName}-sns-notification'
      Description: Sends a notification when the encode job is completed
      Handler: index.handler
      Role: !GetAtt SnsNotificationRole.Arn
      Code:
        S3Bucket: !Join ['-', [!FindInMap ['SourceCode', 'General', 'S3Bucket'], Ref: 'AWS::Region']]
        S3Key: !Join ['/', [!FindInMap ['SourceCode', 'General', 'KeyPrefix'], 'sns-notification.zip']]
      Runtime: nodejs12.x
      Timeout: 120
      Environment:
        Variables:
          AWS_NODEJS_CONNECTION_REUSE_ENABLED: '1'
          ErrorHandler: !GetAtt ErrorHandler.Arn
          SnsTopic: !Ref SnsTopic

  MediaPackageAssetsRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - lambda.amazonaws.com
            Action:
              - sts:AssumeRole
      Policies:
        - PolicyName: !Sub '${AWS::StackName}-media-package-assets-role'
          PolicyDocument:
            Statement:
              - Effect: Allow
                Action:
                  - lambda:InvokeFunction
                Resource:
                  - !Sub 'arn:${AWS::Partition}:lambda:${AWS::Region}:${AWS::AccountId}:function:${AWS::StackName}-error-handler'
              - Effect: Allow
                Action:
                  - iam:PassRole
                Resource:
                  - !GetAtt MediaPackageVodRole.Arn
              - Effect: Allow
                Action:
                  - logs:CreateLogGroup
                  - logs:CreateLogStream
                  - logs:PutLogEvents
                Resource:
                  - !Sub 'arn:${AWS::Partition}:logs:${AWS::Region}:${AWS::AccountId}:log-group:/aws/lambda/*'
              - Effect: Allow
                Action:
                  - mediapackage-vod:CreateAsset
                Resource: '*'
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W11
            reason: '* is used so that the Lambda function can create log groups; MediaPackage action that does not support resource level permissions'

  MediaPackageAssets:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub '${AWS::StackName}-media-package-assets'
      Description: Ingests an asset into MediaPackage-VOD
      Handler: index.handler
      Role: !GetAtt MediaPackageAssetsRole.Arn
      Code:
        S3Bucket: !Join ['-', [!FindInMap ['SourceCode', 'General', 'S3Bucket'], Ref: 'AWS::Region']]
        S3Key: !Join ['/', [!FindInMap ['SourceCode', 'General', 'KeyPrefix'], 'media-package-assets.zip']]
      Runtime: nodejs12.x
      Timeout: 300
      Environment:
        Variables:
          AWS_NODEJS_CONNECTION_REUSE_ENABLED: '1'
          ErrorHandler: !GetAtt ErrorHandler.Arn
          GroupId: !GetAtt MediaPackageVod.GroupId
          GroupDomainName: !GetAtt MediaPackageVod.GroupDomainName
          MediaPackageVodRole: !GetAtt MediaPackageVodRole.Arn

  ErrorHandlerRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - lambda.amazonaws.com
            Action:
              - sts:AssumeRole
      Policies:
        - PolicyName: !Sub '${AWS::StackName}-error-handler-role'
          PolicyDocument:
            Statement:
              - Effect: Allow
                Action:
                  - sns:Publish
                Resource:
                  - !Ref SnsTopic
              - Effect: Allow
                Action:
                  - dynamodb:UpdateItem
                Resource:
                  - !Sub 'arn:${AWS::Partition}:dynamodb:${AWS::Region}:${AWS::AccountId}:table/${DynamoDBTable}'
              - Effect: Allow
                Action:
                  - logs:CreateLogGroup
                  - logs:CreateLogStream
                  - logs:PutLogEvents
                Resource:
                  - !Sub 'arn:${AWS::Partition}:logs:${AWS::Region}:${AWS::AccountId}:log-group:/aws/lambda/*'
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W11
            reason: '* is used so that the Lambda function can create log groups'

  ErrorHandler:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub '${AWS::StackName}-error-handler'
      Description: Captures and processes workflow errors
      Handler: index.handler
      Role: !GetAtt ErrorHandlerRole.Arn
      Code:
        S3Bucket: !Join ['-', [!FindInMap ['SourceCode', 'General', 'S3Bucket'], Ref: 'AWS::Region']]
        S3Key: !Join ['/', [!FindInMap ['SourceCode', 'General', 'KeyPrefix'], 'error-handler.zip']]
      Runtime: nodejs12.x
      Timeout: 120
      Environment:
        Variables:
          AWS_NODEJS_CONNECTION_REUSE_ENABLED: '1'
          DynamoDBTable: !Ref DynamoDBTable
          SnsTopic: !Ref SnsTopic

  IngestWorkflow:
    Type: AWS::StepFunctions::StateMachine
    Properties:
      StateMachineName: !Sub '${AWS::StackName}-ingest'
      DefinitionString: !Sub |
        {
          "StartAt": "Input Validate",
          "States": {
            "Input Validate": {
              "Type": "Task",
              "Resource": "${InputValidate.Arn}",
              "Next": "Mediainfo"
            },
            "Mediainfo": {
              "Type": "Task",
              "Resource": "${Mediainfo.Arn}",
              "Next": "DynamoDB Update"
            },
            "DynamoDB Update": {
              "Type": "Task",
              "Resource": "${DynamodbUpdate.Arn}",
              "Next": "SNS Choice"
            },
            "SNS Choice": {
              "Type": "Choice",
              "Choices": [
                {
                  "Variable": "$.enableSns",
                  "BooleanEquals": true,
                  "Next": "SNS Notification"
                }
              ],
              "Default": "Process Execute"
            },
            "SNS Notification": {
              "Type": "Task",
              "Resource": "${SnsNotification.Arn}",
              "Next": "Process Execute"
            },
            "Process Execute": {
              "Type": "Task",
              "Resource": "${StepFunctions.Arn}",
              "End": true
            }
          }
        }
      RoleArn: !GetAtt StepFunctionsServiceRole.Arn

  ProcessWorkflow:
    Type: AWS::StepFunctions::StateMachine
    Properties:
      StateMachineName: !Sub '${AWS::StackName}-process'
      DefinitionString: !Sub |
        {
          "Comment": "Process StateMachine to create MediaConvert Encoding Jobs",
          "StartAt": "Profiler",
          "States": {
            "Profiler": {
              "Type": "Task",
              "Resource": "${Profiler.Arn}",
              "Next": "Encoding Profile Check"
            },
            "Encoding Profile Check": {
              "Type": "Choice",
              "Choices": [
                {
                  "Variable": "$.isCustomTemplate",
                  "BooleanEquals": true,
                  "Next": "Custom jobTemplate"
                },
                        {
                  "Variable": "$.encodingProfile ",
                  "NumericEquals": 2160,
                  "Next": "jobTemplate 2160p"
                },
                {
                  "Variable": "$.encodingProfile ",
                  "NumericEquals": 1080,
                  "Next": "jobTemplate 1080p"
                },
                {
                  "Variable": "$.encodingProfile ",
                  "NumericEquals": 720,
                  "Next": "jobTemplate 720p"
                }
              ]
            },
            "jobTemplate 2160p": {
              "Type": "Pass",
              "Next": "Accelerated Transcoding Check"
            },
            "jobTemplate 1080p": {
              "Type": "Pass",
              "Next": "Accelerated Transcoding Check"
            },
            "jobTemplate 720p": {
              "Type": "Pass",
              "Next": "Accelerated Transcoding Check"
            },
            "Custom jobTemplate": {
              "Type": "Pass",
              "Next": "Accelerated Transcoding Check"
            },
            "Accelerated Transcoding Check": {
              "Type": "Choice",
              "Choices": [
                {
                  "Variable": "$.acceleratedTranscoding",
                  "StringEquals": "ENABLED",
                  "Next": "Enabled"
                },
                {
                  "Variable": "$.acceleratedTranscoding",
                  "StringEquals": "PREFERRED",
                  "Next": "Preferred"
                },
                {
                  "Variable": "$.acceleratedTranscoding",
                  "StringEquals": "DISABLED",
                  "Next": "Disabled"
                }
              ]
            },
            "Enabled": {
              "Type": "Pass",
              "Next": "Frame Capture Check"
            },
            "Preferred": {
              "Type": "Pass",
              "Next": "Frame Capture Check"
            },
            "Disabled": {
              "Type": "Pass",
              "Next": "Frame Capture Check"
            },
            "Frame Capture Check": {
              "Type": "Choice",
              "Choices": [
                {
                  "Variable": "$.frameCapture",
                  "BooleanEquals": true,
                  "Next": "Frame Capture"
                },
                {
                  "Variable": "$.frameCapture",
                  "BooleanEquals": false,
                  "Next": "No Frame Capture"
                }
              ]
            },
            "Frame Capture": {
              "Type": "Pass",
              "Next": "Encode Job Submit"
            },
            "No Frame Capture": {
              "Type": "Pass",
              "Next": "Encode Job Submit"
            },
            "Encode Job Submit": {
              "Type": "Task",
              "Resource": "${Encode.Arn}",
              "Next": "DynamoDB Update"
            },
            "DynamoDB Update": {
              "Type": "Task",
              "Resource": "${DynamodbUpdate.Arn}",
              "End": true
            }
          }
        }
      RoleArn: !GetAtt StepFunctionsServiceRole.Arn

  PublishWorkflow:
    Type: AWS::StepFunctions::StateMachine
    Properties:
      StateMachineName: !Sub '${AWS::StackName}-publish'
      DefinitionString: !Sub |
        {
          "StartAt": "Validate Encoding Outputs",
          "States": {
            "Validate Encoding Outputs": {
              "Type": "Task",
              "Resource": "${OutputValidate.Arn}",
              "Next": "Archive Source Choice"
            },
            "Archive Source Choice": {
              "Type": "Choice",
              "Choices": [
                {
                  "Variable": "$.archiveSource",
                  "StringEquals": "GLACIER",
                  "Next": "Archive"
                },
                {
                  "Variable": "$.archiveSource",
                  "StringEquals": "DEEP_ARCHIVE",
                  "Next": "Deep Archive"
                }
              ],
              "Default": "MediaPackage Choice"
            },
            "Archive": {
              "Type": "Task",
              "Resource": "${ArchiveSource.Arn}",
              "Next": "MediaPackage Choice"
            },
            "Deep Archive": {
              "Type": "Task",
              "Resource": "${ArchiveSource.Arn}",
              "Next": "MediaPackage Choice"
            },
            "MediaPackage Choice": {
              "Type": "Choice",
              "Choices": [
                {
                  "Variable": "$.enableMediaPackage",
                  "BooleanEquals": true,
                  "Next": "MediaPackage Assets"
                }
              ],
              "Default": "DynamoDB Update"
            },
            "MediaPackage Assets": {
              "Type": "Task",
              "Resource": "${MediaPackageAssets.Arn}",
              "Next": "DynamoDB Update"
            },
            "DynamoDB Update": {
              "Type": "Task",
              "Resource": "${DynamodbUpdate.Arn}",
              "Next": "SQS Choice"
            },
            "SQS Choice": {
              "Type": "Choice",
              "Choices": [
                {
                  "Variable": "$.enableSqs",
                  "BooleanEquals": true,
                  "Next": "SQS Send Message"
                }
              ],
              "Default": "SNS Choice"
            },
            "SQS Send Message": {
              "Type": "Task",
              "Resource": "${SqsSendMessage.Arn}",
              "Next": "SNS Choice"
            },
            "SNS Choice": {
              "Type": "Choice",
              "Choices": [
                {
                  "Variable": "$.enableSns",
                  "BooleanEquals": true,
                  "Next": "SNS Notification"
                }
              ],
              "Default": "Complete"
            },
            "SNS Notification": {
              "Type": "Task",
              "Resource": "${SnsNotification.Arn}",
              "Next": "Complete"
            },
            "Complete": {
              "Type": "Pass",
              "End": true
            }
          }
        }
      RoleArn: !GetAtt StepFunctionsServiceRole.Arn

  Uuid:
    Condition: Metrics
    Type: Custom::UUID
    Properties:
      ServiceToken: !GetAtt CustomResource.Arn
      Resource: UUID

  AnonymousMetric:
    Condition: Metrics
    Type: Custom::LoadLambda
    Properties:
      ServiceToken: !GetAtt CustomResource.Arn
      SolutionId: SO0021
      UUID: !GetAtt Uuid.UUID
      Version: 'v5.1.0'
      Transcoder: MediaConvert
      WorkflowTrigger: !Ref WorkflowTrigger
      Glacier: !Ref Glacier
      FrameCapture: !Ref FrameCapture
      Resource: AnonymousMetric
      EnableMediaPackage: !Ref EnableMediaPackage
